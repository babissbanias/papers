% prelude latex <<<
\tracingmacros=0
\documentclass{llncs}
% packages <<<
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{graphicx}  % TODO: paint everything in tikz and remove this
\usepackage{listings}
\usepackage{mathrsfs}
\usepackage{microtype} % keep even if it seems not to do anything!
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage[colorlinks]{hyperref}  % solves pdfTeX warning (ext4)?
\usepgflibrary{arrows}
% >>>
% meta <<<
\title{FreeBoogie}
\subtitle{201105}
\author{Radu Grigore\inst{1} and Joseph Roland Kiniry\inst{2}}
\institute{Queen Mary, University of London
\and IT University of Copenhagen}
% >>>
% PDF settings <<<
\definecolor{darkblue}{rgb}{0,0,0.4}
\definecolor{verylightgray}{rgb}{0.9,0.9,0.9}
% comment the next line for printing
\hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkblue}
\hypersetup{
  pdfauthor={Radu Grigore and Joseph Kiniry},
  pdftitle={FreeBoogie}}
% >>>
% tikz helpers <<<

% global styles
\tikzstyle{arr}=[->,>=stealth']
\tikzstyle{predcirc}=[
  circle,
  very thick,
  fill=green!10,
  draw=green,
  minimum size=14pt,
  inner sep=0pt]
\tikzstyle{predrect}=[predcirc,rectangle,inner sep=2pt]

% These macros and styles are used for drawing flowgraphs
\newcommand\fgnodeR{2pt}  % the default radius of a flowgraph node
\tikzstyle{fgdraw}=[
  minimum size=2*\fgnodeR,inner sep=0pt,outer sep=1pt,
  draw,thick]
\tikzstyle{fgfill}=[fill=black]
\ifx\fgnode\undefined\else\errmessage{\string\fgnode already defined!}\fi
\def\fgnode#1#2(#3) at (#4){% uses \def because of the special syntax
    \begin{scope}[shift={(#4)},shift only]
      \clip (-\fgnodeR,-#1*\fgnodeR) rectangle (\fgnodeR,#2*\fgnodeR);
      \node[fgdraw,circle,fgfill] {};
    \end{scope}
    \node[fgdraw,circle] (#3) at (#4)}
\newcommand{\oonode}{\fgnode00} % the normal non-reading non-writing node
\newcommand{\ronode}{\fgnode01} % for read-only nodes
\newcommand{\wonode}{\fgnode10} % for write-only nodes
\newcommand{\rwnode}{\fgnode11} % for read-write nodes
\newcommand{\gnode}{\node[fgdraw,circle,fill=gray]}  % gray nodes (ra)
\newcommand{\cnode}{\node[fgdraw,fgfill,rectangle]} % copy nodes
\newcommand{\enode}{\oonode} % empty node
\newcommand{\fnode}{\rwnode} % filled node
% >>>
% package customization <<<
\lstset{
  basicstyle=\scriptsize,
  identifierstyle=\itshape,
  stringstyle=\footnotesize\ttfamily,
  commentstyle=\textup,
  columns=fullflexible,
  numbers=left,
  numberstyle=\tiny,
  mathescape=true,
  boxpos=t,
}
\lstdefinestyle{boogie}{
  morekeywords={procedure,returns,assume,assert,havoc,goto,return,
    int,bool,type,while,if,true,false,function,bool,returns,axiom,
    forall,var}
}
\lstdefinestyle{jml}{
  language=java,
  morekeywords={requires,ensures,old,invariant,forall,exists,axiom,also,
    result,pure,assert,modifies},
  deletekeywords={label}
}
\lstdefinestyle{smt}{
  morekeywords={ite,true,false,BG_PUSH,IFF,FORALL,EQ,NEQ,NOT,TRUE,FALSE,
    IMPLIES}
}
\newcommand{\lstinlinen}{\lstinline[basicstyle=\normalsize]}
\newcommand{\boogieCode}{\lstinline[style=boogie,basicstyle=\normalsize]}
\newcommand{\jmlCode}{\lstinline[style=jml,basicstyle=\normalsize]}
\newcommand{\smtCode}{\lstinline[style=smt,basicstyle=\normalsize]}
\newcommand{\deflang}[1]{\lstnewenvironment{#1}[1][]{\lstset{style=#1,##1}}{}}
\deflang{jml}
\deflang{boogie}
\deflang{smt}
\abovetopsep=1ex % because tabular appears below captions
% >>>
% new commands <<<
\def\fb#1{{\bf #1}} % for introducing acronyms
\newcommand{\csharp}{C$^\sharp$\xspace}
\newcommand{\escjava}{ESC\slash Java\xspace}
\newcommand{\framac}{\hbox{Frama-C}}
\newcommand{\jk}[1]{{\small [\textcolor{red}{jk}: #1]}}
\newcommand{\rg}[1]{{\small [\textcolor{red}{rg}: #1]}}
\newcommand{\shell}[1]{\\\leftline{\indent\indent\footnotesize\texttt{#1}}}
\newcommand{\specsharp}{Spec$^\sharp$\xspace}

%pairs
\newcommand{\bc}{\begin{figure}\centering\begin{tabular}{c}} % begin codebox
\newcommand{\ec}[2]{\end{tabular}\caption{#1}\label{#2}\end{figure}} % end codebox

% >>>
% TeX settings <<<
\overfullrule=5pt
\showboxdepth=10
\showboxbreadth=100
% >>>
% >>>
% boogie and lncs instructions <<<
% - 12 pages, lncs format
% >>>
\begin{document}
\maketitle
% abstract <<<
\begin{abstract}
We describe the current design of FreeBoogie, a static verifier for Boogie
programs.
\end{abstract}
% >>>
\section{Introduction} % <<<

``Why another static verifier for Boogie? Is there something so wrong with
the one from Microsoft Research that it cannot be fixed?'' We expect that
many readers have these thoughts at this point, so we answer.  FreeBoogie
exists because we wanted to change the Boogie language back in 2007 and
Microsoft's verifier was closed source at the time. We keep FreeBoogie
alive for three main reasons. First, we like the Boogie language and
history shows that languages have higher chances to survive if they have
multiple implementations. Second, the FreeBoogie project has distinct
priorities, namely simplicity of its code and good documentation. Third,
FreeBoogie is easy to compile and use on Linux, because it is written
in~Java.

This paper is written for researchers that want to experiment with the
Boogie language. For example, one might be interested in verifying Boogie
programs by symbolic execution rather than verification-condition
generation; another might be interested in adding the heap to Boogie's
semantics rather than keeping it as a global array; yet another might want
to infer procedure specifications for a set of given implementations. These
are all experiments that could be made by modifying FreeBoogie. The main
technical challenge is then to understand FreeBoogie enough to modify it.
Luckily, its code was written so that it is easy to understand. Even
better, this article gives a high-level overview of the design, and points
to the tricky pieces of code, so that you can get up to speed quickly.

The rest of the article assumes that the reader checked out FreeBoogie. Run
\shell{svn co -r \{20110531\} http://freeboogie.googlecode.com/svn/trunk/ fb}%
\shell{cd fb/FreeBoogie}
and then follow the instructions in \texttt{README}.

% >>>
\section{The Pipeline} % <<<

The best way to understand how FreeBoogie works is to run it on a few
examples and ask it to dump its data structures at intermediate stages.
Figure~\ref{lst:boogie-indexof} shows a Boogie program suitable for a first
run. To peek at FreeBoogie's internals use the following command. \rg{Use a
file from the repo.} \shell{fb --dump-intermediate-stages=log example.bpl}
This will create a directory \texttt{log}. The output of each processing
phase of FreeBoogie appears in a subdirectory of~\texttt{log}. The name of
the subdirectory is the name of the phase. \rg{The pipeline is built by
code in $\ldots$} \rg{Each subdir contains code plus aux info (types,
symbol table, flowgraph.)}


The flowgraph is an example of \emph{auxiliary} information that
FreeBoogie computes after each transformation. The other pieces
of auxiliary information are the symbol table and the types. The
\emph{symbol table} is a one-to-many bidirectional map between
identifier definitions and identifier uses. The \emph{types} are
associated with expressions (and subexpressions).

To see the query that is sent to the theorem prover you must run a
different command. \rg{Use file in repo} \shell{fb -lf=example.log -ll=info
-lc=prover example.bpl} The log file \texttt{example.log} will contain
everything sent to the prover. The result of the whole run is \shell{OK:
indexOf at example.bpl:2:11} indicating that the program is correct.

\rg{In general, $\ldots$}
\rg{Get rid of colors.}
Figure~\ref{fig:architecture} shows that FreeBoogie has a
pipeline architecture. The \colorbox{green!50!white}{light green}
color stands for the Boogie AST (\fb abstract \fb syntax \fb
tree); the \colorbox{blue!50!black}{\textcolor{white}{dark blue}}
color stands for the SMT AST\null.

\begin{figure} % <<<
  \centering
  \begin{tikzpicture}[scale=1]
  \tikzstyle phaseS=[thick,rounded corners=2pt,draw=black,fill=white];
  \fill[color=green!50!white] (0,-0.25) rectangle +(6,-4.75);
  \fill[color=blue!50!black] (0,-4.75) rectangle +(6,-1.5);
  \foreach \py/\px/\ptext in {
    0/5.45/parse,
    1/5.45/desugar \textbf{break},
    2/5.45/desugar \textbf{while},
    3/5.45/desugar \textbf{if},
    4/5.45/handle loops,
    5/5.45/desugar \textbf{call},
    6/5.45/desugar \textbf{havoc},
    7/5.45/desugar specifications,
    8/5.45/remove assignments,
    9/6/compute VC,
    10/6/add prover-dependent axioms,
    11/6/simplify VC,
    12/6/query a prover}
  {
    \draw[phaseS]
     [yscale=.5](0,-\py-0.1) rectangle node {\ptext}  +(\px,-.8);
  }
  \draw[phaseS] (5.55,-0.25) rectangle node[rotate=-90] 
    {update extra information} (6,-4.45);

  \end{tikzpicture}
  \caption{FreeBoogie architecture.}
  \label{fig:architecture}
  \rg{Only say `desugar', not what kind of desugaring.}
\end{figure} % >>>

\rg{Put this in the figure (`transf', `Boogie transf', $\ldots$)}
Horizontal boxes, except for the first one (parse) and the last
one (query a prover), represent \emph{transformations}. Depending
on the type of input and on the type of output there are three
types of transformations: Boogie to Boogie, Boogie to SMT, and
SMT to SMT\null. For brevity, we say `Boogie transformations'
instead of `Boogie to Boogie transformations', and `SMT
transformations' instead of `SMT to SMT transformations'. All
these transformations are designed not to miss bugs, at the cost
of possible false positives.

\rg{Less formal:}
A Boogie transformation is \emph{sound} when it produces only
incorrect Boogie programs from incorrect Boogie programs. A
Boogie to SMT transformation is \emph{sound} when it produces
only invalid formulas from incorrect Boogie programs. An SMT
transformation is \emph{sound} when it produces only invalid
formulas from invalid formulas.

The symmetric notion is that of completeness.

\rg{Less formal and shorter.}
A Boogie transformation is \emph{complete} when it produces
only correct Boogie programs from correct Boogie programs. A
Boogie to SMT transformation is \emph{complete} when it produces
only valid formulas from correct Boogie programs. An SMT
transformation is \emph{complete} when it produces only valid
formulas from valid formulas.

All transformations in FreeBoogie are sound; all transformations
in FreeBoogie, except loop handling, are complete.

Full Boogie would not be user friendly without high-level
constructs like \textbf{while} statements and \textbf{break}
statements. Many phases in FreeBoogie perform syntactic
desugarings of these constructs. The desugaring is sometimes
local, in the sense that it can be done without keeping track of
an environment, and sometimes it is not. For example, to desugar
the \textbf{break} statement we must keep track of the enclosing
\textbf{while} and \textbf{if} statements; but the desugaring of
a \textbf{havoc} statement does not depend on any surrounding
code. \rg{Must refer back to this when discussing visitors and their state.}

The most important transformation in FreeBoogie is the
transition from Boogie to SMT\null. The role of preceding Boogie
transformations is to simplify the program to a form on which the
VC is easily computed; the role of subsequent SMT transformations
is to bring the VC to a form that is easily handled by a prover.

The order of Boogie transformations depends on constraints
such as the following. The Boogie to SMT transformation
(`compute VC' in Figure~\ref{fig:architecture}) only handles
the \textbf{assert}, \textbf{assume}, and \textbf{goto}
statements. The Boogie transformation that removes assignments
only handles acyclic flowgraphs. Hence, the flowgraph must
first be transformed into an acyclic one (`handle loops' in
Figure~\ref{fig:architecture}).

The VC uses concepts such as arrays, which may or may not be
known to the prover. In the latter case, axioms that describe
the concept must be added to the VC\null. Finally, the VC is
simplified so that the communication with the prover is
more efficient. \rg{Check if I actually do any simplifications.}

The source code of FreeBoogie, written in Java~6, contains
four packages, which are in one-to-one correspondence with the
following sections.

\begin{itemize}
\item \texttt{freeboogie.ast}: data structures for representing
  Boogie programs and facilities for processing such data structures
\item \texttt{freeboogie.tc}: code that computes auxiliary information
  from a Boogie AST
\item \texttt{freeboogie.vcgen}: the Boogie transformations and
  the Boogie to SMT transformation
\item \texttt{freeboogie.backend}: 
  SMT transformations, 
  data structures for representing SMT, 
  and code for interfacing with the prover
\end{itemize}

% >>>
\section{The Abstract Syntax Tree and its Visitors} % <<<
\label{sec:design.ast}
% @review JRK *want*, but needs a lot of trimming (see below)

The Boogie AST data structures are described using a compact notation. A
subset, corresponding to core Boogie, appears in
Figure~\ref{fig:boogie-absgrm}. AstGen (a helper tool) reads this
description and a code template to produce Java classes. The approach has
advantages and disadvantages. The generated classes are very similar to
each other because they come from the same template. This means that it is
easy to learn their interface.  It also means that it is easier to change
all the classes in a consistent way by changing the template. The compact
description in \rg{file fb.ag} is easier to read than the corresponding
\rg{gazillion} Java classes. The overall structure of the AST is easier to
grasp. It is also easier to modify, since it takes far less time to change
one or two lines than one or two Java classes. However, the programmer
needs to learn a new language (the one used in
Figure~\ref{fig:boogie-absgrm}) and IDEs are often confused by code
generators.

\rg{Must mention where the template is, and the main methods one needs to
know. (Such as \texttt{withBla}.)}

Another consequence of this approach, which might be seen as a
disadvantage, is that there is no way to add specific code to
specific classes: We are forced to implement operations over the
AST using the visitor pattern~\cite{gamma1995}.

\subsection{Visitors} % <<<
\label{sec:visitors}

\rg{Typeset $<$ as $\langle$.}
\rg{Get rid of $\mathscr A$.}
\rg{Rewrite this paragraph: even I got bored and glanced over.}
FreeBoogie uses the visitor pattern and
the root of the visitors' class hierarchy is the class
\jmlCode|Evaluator<R>|. The root of the Boogie AST
class hierarchy is the class \jmlCode|Ast|. A subclass
of \jmlCode|Evaluator<R>| is like a function of type
$\mathit{Ast}\to R$, in the sense that it associates a
value of type~$R$ (possibly \jmlCode|null|) to an AST
node. For example, the type checker is a subclass of
\jmlCode|Evaluator<Type>|. The base class \jmlCode|Evaluator|
declares one \jmlCode|eval($\mathscr{A}$)| method for each AST
class~$\mathscr{A}$. These methods
are not only declared, but they are also implemented, so that
subclasses explicitly handle only the relevant types of AST
nodes. For all the other AST node types, the default behavior
implemented in \jmlCode|Evaluator| is to recursively evaluate all
children and to cache the results. Because the \jmlCode|eval|
methods of \jmlCode|Evaluator| are so similar, they are generated
from an AstGen template.

An important type of evaluator is a transformer: The class
\jmlCode|Transformer| extends \jmlCode|Evaluator<Ast>|. The
main functionality implemented in \jmlCode|Transformer|, path
copying, is illustrated in Figure~\ref{fig:path-copying}. Empty
nodes (\tikz[baseline=-.5ex] \node[fgdraw,circle] {}; and
\tikz[baseline=-.5ex] \node[fgdraw]{};) represent AST nodes
that exist on the heap before a transformer~$T$ acts; filled
nodes (\tikz[baseline=-.5ex] \node[fgdraw,fgfill,circle]{};
and \tikz[baseline=-.5ex] \node[fgdraw,fgfill]{};) represent
AST nodes created by the transformer~$T$. Because the
transformer~$T$ is interested only in rectangle nodes,
it overrides only the \jmlCode|eval| method that takes
rectangles as parameters. That overriden method is responsible
for creating the filled rectangle (\tikz[baseline=-.5ex]
\node[fgdraw,fgfill]{};). All the other filled nodes
(\tikz[baseline=-.5ex] \node[fgdraw,fgfill,circle]{};) are
created by \textit{Transformer}, and need not be of any concern
to the particular transformer~$T$.

\begin{figure}\centering
\begin{tikzpicture}
  [level distance=7mm,
  level/.style={sibling distance=5cm/(#1^1.5)}]
\tikzset{tree/.style={fgdraw,circle}}
\node[tree] (A) {}
  child {node[tree] (B) {}
    child {node[tree] (B1) {}}
    child {node[tree,rectangle] (C) {}
      child {node[tree] (C1) {}}
      child {node[tree] (C2) {}}
    }
    child {node[tree] (B3) {}}
  }
  child {node[tree] (A2) {}
    child {node[tree] {}
      child {node[tree] {}}
      child {node[tree] {}}
    }
    child {node[tree] {}}
    child {node[tree] {}}
  };
\path
  (A) +(1cm,0) node[tree,fgfill] (A') {}
  (B) +(1cm,0) node[tree,fgfill] (B') {}
  (C) +(1cm,0) node[tree,fgfill,rectangle] (C') {};
\draw (A') -- (B') -- (C');
\draw (A') -- (A2);
\draw (B') -- (B1); \draw (B') -- (B3);
\draw (C') -- (C1); \draw (C') -- (C2);
\node[above left] at (A) {input};
\node[above right] at (A') {output};
\end{tikzpicture}
\caption{Path copying}\label{fig:path-copying}
\end{figure}

The input and the output of a transformer usually share a large number of
nodes. Since \textit{Evaluator} caches the information that various
evaluators associate with AST nodes, there is no need to repeat the
computation of that auxiliary information for the shared parts. \rg{Don't
use `auxiliary'. Reserve that word for tc, st, and fg.} For example, most
of the type information is already in the cache of the type checker.

\rg{Make more convincing.}
Sometimes a transformer wants to `see' AST nodes of type~$A$
even if it computes no value for them. A typical example is
a pretty printer. In such cases a transformer may override
\jmlCode|eval(A)| and return \textbf{null}. A nicer solution is
to override \jmlCode|see(A)|, whose return type is \textbf{void}.
If both \jmlCode|eval(A)| and \jmlCode|see(A)| are overriden,
then the former will be called by the traversal code in
\textit{Transformer}.

% >>>
\subsection{Immutability} % <<<
\label{sec:design.immutability}
% @review JRK *want* (but tighten-up)

In Java programming, it is unusual to constrain data structures
to be immutable. Since the resulting code may look awkward to
many programmers, there better be some good reasons for this
design decision. In fact, awkward code, such as copying all but
one of the fields in a new object instead of doing a simple
assignment, is only one of the apparent problems.

\bc
\begin{jml}
public class Renamer extends Transformer {
  @Override public Identifier eval(Identifier identifier) {
    if (!identifier.id().equals("u")) return identifier;
    else return Identifier.mk("v");
  }
}
\end{jml}
\ec{Changing all occurrences of variable~$v$ into variable~$y$}
{lst:example-transformer}

Immutability implies path copying, which is a potential performance
problem. Consider the task of changing all occurrences of the variable~$u$
into variable~$v$, which is achieved by the transformer in
Figure~\ref{lst:example-transformer}. Suppose an AST with height~$h$ and
$n$~nodes contains exactly one occurrence of variable~$u$. If the class
\textit{Identifier} would be mutable, one assignment would be enough to
achieve the substitution; since the class \textit{Identifier} is immutable,
about $h$ new nodes must be created and initialized. However, if there are
two occurrences of variable~$u$, they share some ancestors, meaning that
less than about $2h$ new AST nodes must be created and initialized. Even
more, if we take into account the tree traversal, then both
implementations, with a mutable AST and with an immutable AST, take
$\Theta(n)$ time \rg{where $n\ldots$}. In other words, there is no
asymptotic slowdown.

A Boogie block contains a \emph{list} of statements (see
Figure~\ref{fig:boogie-absgrm}). Such lists should be immutable,
but there are no immutable lists in the Java API (\fb application
\fb programming \fb interface), only immutable \emph{views} of
lists. Immutable collections can be implemented such that
immutability is enforced statically by the compiler or such
that immutability is enforced by runtime checks. Unfortunately,
the former is incompatible with implementing Java API
interfaces~\cite{javaCollectFaq}. For example, in order to use
the iteration statement
\jmlCode|for (T x : xs)|,
one must implement the interface \textit{Iterable} that
contains the method \textit{remove}. Obviously, calls to
the \textit{remove} method are not prevented statically by
the compiler. FreeBoogie uses the \textit{ImmutableList}
class from the Google Collections~\cite{google-collect}
library \rg{guava!}, which follows the approach with runtime checks.

However, the advantages of immutability outweigh its
disadvantages.

First, immutability enables \textit{Evaluator} to cache the
results of previous computations, because only immutable data
structures can be used as keys in maps. A particular evaluator,
such as the type-checker, need not mention anywhere in its
implementation that caching is used. Yet, if the type-checker
is invoked twice on the same AST fragment, then the second call
will return immediately. This leads to cleaner code also because
AST transformers need not bother with updating the auxiliary
information---recomputing it is cheap.

Second, immutability makes the code easier to understand, because
it frees the programmer from thinking about aliasing of AST nodes.
In Java, any mutation of \jmlCode|u.f| must be done only after
thinking how it will affect code that uses possible aliases of~$u$.
Because the AST is a central data structure in FreeBoogie, there
is a lot of potential aliasing that must be considered whenever
a mutation is done. It is much simpler to forbid mutations altogether.

Still, there are situations when the programmer must think about aliasing
of AST data structures. It is natural to think of an AST reference as
\emph{being} a piece of a Boogie program, even if, strictly speaking, it
only \emph{represents} a piece of a Boogie program. To maintain this useful
illusion the programmer must ensure that no sharing occurs within
\emph{one} version of the AST\null. In practice, this means that the
programmer must occasionally clone pieces of the AST when implementing
transformers. (The \textit{clone} method is implemented in the code
template for AST classes.)

% >>>
% >>>
\section{Auxiliary Information} % <<<
% @review JRK *want*

The package \textit{freeboogie.tc} derives extra information from
a Boogie AST---types, a symbol table, and a flowgraph.

The AST constructed by the parser is type-checked in order to
catch simple mistakes in the input. As a safeguard against bugs,
the AST is type-checked after each transformation. A side-effect
of type-checking is that the type of each expression is known.

\rg{Rephrase.}
The symbol table helps in navigating the AST\null. It consists of
one-to-many bidirectional maps that link identifier declarations
to places where the identifiers are used. All
these maps are in the class \textit{SymbolTable}.
Another bidirectional map is built by
\textit{ImplementationChecker}: In full Boogie a \emph{procedure}
may have zero, one, or multiple \emph{implementations}. 

Finally, it is sometimes convenient to view one implementation as a
flowgraph whose nodes are statements. Such a flowgraph is built by
\textit{FlowGraphMaker}. \rg{Say that unreachable nodes get warnings and
mention SimpleGraph?}

All auxiliary information is available through
\textit{TcInterface}, which is an implementation of the Facade
pattern.

% >>>
\section{Verification Condition Generation} % <<<
% @review JRK *want*

The package \textit{freeboogie.vcgen} consists of Boogie
transformers and Boogie to SMT transformers. The facade of this
package is the class \textit{VcGenerator}.

Most Boogie transformers are responsible for small AST
modifications such as desugaring an \textbf{if} statement
into \textbf{assume} and \textbf{goto} statements. For speed,
it would be better to cluster many such simple transformers
into one, but the code is simpler if they are kept
separate. A few helper classes are used by multiple Boogie
transformers: \textit{CommandDesugarer} is used as a base class
by transformers that change statements into lists of statements;
\textit{ReadWriteSetFinder} is an evaluator that associates with
each statement two sets---the set of variables that are read and
the set of variables that are written.

Boogie transformations do not update the auxiliary information
while they are building new AST nodes. Instead, at the very end,
they recompute all auxiliary information, and caches ensure that
no computation is repeated. This way, bugs that produce untypable
Boogie programs get caught at run-time. (Type information is
auxiliary information, so type-checking is repeated. \rg{remove?})

The Boogie to SMT transformation is done by the
class \textit{WeakestPrecondition} or by the class
\textit{StrongestPostcondition}, depending on the command line
options. The theory behind these two classes is presented in
Chapter~\ref{ch:spwp}.

% >>>
\section{The Prover Backend} % <<<
\label{sec:design.backend}
% @review JRK *want*

The package \textit{freeboogie.backend} contains SMT data
structures and code to communicate with provers.

\rg{I think I need to add back how sort checking is done. I'm not sure I
agree with Joe that it was pedantic, and a little must be said anyway.}

\rg{Need to say: (1) how to add new symbols and (2) axioms that are added
only when certain symbols are used.}

\subsection{Talking to the Prover} % <<<
% @review JRK *want*

\rg{Check the code: I have a vague feeling there's something more
interesting to say here.}

The class \textit{Prover} defines the interface that is used
by the package \textit{freeboogie.vcgen} to talk to the
prover. It is a thin interface, consisting of the methods
\textit{assume}, \textit{retract}, \textit{push}, \textit{pop},
and \textit{isValid}.

The real prover does not have to have the notion of an
assumption (also known as hypothesis), but a class that extends
\textit{Prover} should take advantage of all facilities of a real
prover. For example, if Simplify is used as a prover, then a
sequence of calls \jmlCode|assume(h)|, \jmlCode|isValid($q_1$)|,
\jmlCode|isValid($q_2$)| may result in one of the following two
strings being sent to the prover:
\begin{align}
&(\mathbf{IMPLIES}\;h\;q_1)\;(\mathbf{IMPLIES}\;h\;q_2)\\
&(\mathbf{BG\_PUSH}\;h)\;q_1\;q_2
\end{align}
Both are OK, but the second is better, if only because
$h$ is communicated once.

Similarly, a class that extends \textit{Prover} may choose to
treat certain SMT tree labels specially to take advantage of
other facilities of the real prover.

% >>>
% >>>
\section{Dependencies} % <<<

\rg{Keep short. Mention CLOPS, AstGen, GenericUtils, Guava, the d/l
process.}

% >>>
\section{Related Work} % <<<
% @review JRK *want*  (though must be trimmed---also,  a discussion of
% Cok's jSMTLIB is now necessary)

\rg{Say that this evolved from chapter X in my thesis.}
\rg{Mention Boogie, Spec$\sharp$, B2BPL, SMTLIB (including jSMTLIB) and
nothing else. Keep short.}
\rg{The comparison with Boogie needs to be good.}

% >>>
\section{Conclusion} % <<<
% @review JRK *want* A conclusion.

\rg{Not sure what to say here.}

% >>>
\bibliographystyle{plain}
\bibliography{fb}
\end{document}
% vim:spell errorformat=%f\:%l-%m,%f\:%l\:%m,%f\:%m
% vim:tw=75:fo+=t:fmr=<<<,>>>:
