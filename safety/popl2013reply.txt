First of all, we thank the reviewers for carefully reading the paper and
for their feedback.



Several reviewers are concerned about the expressivity of TOPL:
  * "It is unclear whether TOPL can capture practical properties that other
    formalisms cannot (a large number of useful properties and many that
    the authors look at in their evaluation are single-object typestate)"
  * "I feel that the general usefulness and applicability of (r)TOPL
     automata is not so clear."
  * "other formalisms proposed allow taking data into account and
    seem to be able to express all properties proposed in this paper."
  * "the authors do not show what a possible formalization of the example
    properties would look like in other formalisms."

Let us make three observations.

1. Our precise result concerning expressivity is that it is the same as
that of register automata, a formal model that predates those that underlie
popular runtime verification tools.

2. We chose examples (Section 6) that are not expressible in many other
formalisms that are currently used for runtime verification.  For example,
all properties that need re-binding (such as ListNotCyclic, IterateRopes,
and TaintCheck) cannot be expressed by any formalism based on trace slicing
(such as JavaMOP, tracematches, and quantified event automata).  We believe
that TaintCheck is a realistic property, because there is a whole field of
research dedicated to taint analysis.  It is fairly easy to see why slicing
does not work.  Consider the following two families of traces, using the
notation from the slicing literature:
  A = { getList<x1> next<x1,x2> next<x2, x3> ... next<xn, x1> | P }
  B = { getList<x1> next<x1,x2> ... next<x(n-1),xn> | P }
where P is "n is natural, and x1, ..., xn are pairwise distinct values".
The property ListNotCyclic fails on all traces in A, and does not fail on
any of the traces in B.  However, given any parameter binding <b1,b2>, the
corresponding slice is one of [], [next], or [getList next], which is not
enough to distinguish between A and B.  In fact, a similar argument works
even for the property SingletonPattern, which does not use re-binding.

3. All properties expressible in JavaMOP with finite automata are also
expressible in TOPL.  This is an easy consequence of Theorem 1 (point 8)
together with our reductions.

We believed that (2) and (3) are obvious consequences of what we said, and
we wished to refrain from overly criticizing other people's work.  Here is
what we did do in the paper:
  * We remarked that rTOPL is as expressive as register automata.
    (Remark 2 at the end of Section 4.2).
  * We chose the examples of Section 6 such that most are not amenable to
    methods based on trace slicing.
  * We emphasized re-binding in Section 2.
  * We remarked in Section 9, with regards to trace slicing approaches:
    ‘Within such a framework, it seems difficult to express some of our
    examples, which naturally use an unbounded number of registers.’
    (Point 2 above elaborates on this remark.)
  * We included point 8 in Theorem 8 precisely because it is the key
    observation in relating to the expressivity of JavaMOP (with finite
    automata).



"The main question is how many of these are actually needed in practice,
i.e., what is the motivation to reduce to register automata ?
For instance, point 6 [not closed under complementation and reversal], is
that really needed when checking properties dynamically ?"

We believe that theoretical connections lead to better understanding.  They
are, in a sense, more important than comparisons of performance and of
subjective expressivity.  The Introduction states: ‘The formal
correspondence between the properties and register automata defined in this
paper gives a rigorous mathematical foundation to the approach and allows
us to reuse many of the results for register automata on TOPL automata.’

Each tool for runtime verification (of Java) seems to have its own formal
foundations, with various degrees of rigour.  (One positive example in
terms of rigor is [26].)  Register automata predate all these formalisms
and they intuitively seemed to us as being adequate for the task.  We set
out to validate this intuition.  However, an implementation in terms of
register automata is cumbersome, which motivates TOPL automata.  Theorem 2
lists several results on TOPL automata, inherited from register automata.
Unfortunately, the language used in automata theory is rather different
from the language used in runtime verification.  We tried to bridge the
gap, but the reviewers still had questions about the relevance of certain
parts to runtime verification.  Thus, let us restate Theorem 2 in the
language of runtime verification:

1. Runtime monitoring is possible.  Moreover it is possible to reliably
detect properties that do not fail for any program, in order to provide a
warning.
2. It is possible to automatically verify the correctness of refactorings
involving properties with at most one register.  In particular, for such
properties it is possible to statically detect if they fail for all
programs.
3. For properties involving more than one register it is *not* possible to
automatically validate refactorings.
4. TOPL properties may be written as (extended) regular expressions, using
the operations | (or) , & (and) , ; (seq), and * (repeat). (But not
extended with negation.)
5. If users would be able to use TOPL properties to specify good behavior
(rather than just bad behavior), then they would be able to specify more
scenarios.

We emphasize that the statements above are exactly those in Theorem 2,
except they are stated using a different vocabulary.

(Note that point 5 in Theorem 1 is inherited from point 6 in Theorem 1, which
is the point singled out by the reviewer in his/her question.)



"Or is combining properties useful ?"

As above, combining properties means that TOPL properties may also be
written in the form of regular expressions (extended, because letters are
replaced with labels, and because intersection is supported).  It also
means that TOPL properties could be reused by name.  For example "A;B"
reuses big descriptions of properties A and B.



"Perhaps there is a direct algorithm for working directly with the
rollback automata and not converting the automata to a register one ?"

That is why rollback TOPL automata are introduced:  They closely reflect
how the implementation works.  Section 4 starts with: ‘We now gradually
move towards a model that is better suited for runtime verification of Java
programs.’  The core of the implementation of the monitors/checkers is
Definition 6.



"what would happen if we try to express the properties directly in TOPL ?"

It is of course always possible to use simple TOPL, since there is a
reduction.  We tried to make TOPL user-friendly as follows:  If one takes a
path from start to error and lists the labels one below the other, then the
result should look like a small Java program that exhibits the bug.  (We saw
the same idea being used in PQL.)  Once you understand this principle, TOPL
does feel friendlier.  However, this entails writing labels like
  I := C.iterator()
which strictly speaking refer to two moments in time that must happen one
after the other.  The skip-semantics (which ignores irrelevant events)
means that a desugaring into two unit transitions won't do what is expected,
in many situations.  Hence, rollback.

The relevant parts of the paper are the first paragraph of Section 4.2 and
the paragraph in Section 5.2 starting with ‘Let us now consider the third
label’.



"what about the relationship among the specification languages? which
properties can be expressed in both systems?"

Please see our note on expressivity in the beginning of this response.



"what do you do when the specification is not met?"

Section 7 states: ‘The checker logs the property violations it detects.’
The input/output behavior of the program is otherwise not affected.  The
resource usage is affected---it uses more memory and more time.



"apparently for efficiency reason, the dynamic checking is not even sound:
it can be the case that a trace does not respect the specifications and the
monitor does not detect it."

There is a setting of the parameters for which monitoring *is* sound: set
the limit on active states to be infinity (or MAX_INT in our
implementation).  The ability to trade soundness for efficiency is the main
idea introduced by QVM, which we appreciate and reuse, albeit with a
different underlying mechanism.



"In particular, the "alphabet" used in TOPL properties basically coincides
with "histories" [Jeffrey, Rathke, 2005]"

There must be some typo: There is no such thing as a ‘history’ in [Jeffrey,
Rathke, 2005], which gives a fully abstract trace semantics for a Java-like
language.  That is obviously orthogonal to our work, as we make no
assumption on how traces are produced.  Moreover, we use the word
‘alphabet’ in a completely standard sense, going back at least to [Rabin,
Scott, 1959].  We did see ‘history’ being used to mean trace whose events
have a certain structure and that also satisfy some extra condition.
However, we really do work with plain traces: The structure of events is
only relevant for the syntax we chose for TOPL, but does not affect
semantics.



"Another criticism to the paper is that one of the selling points of TOPL
properties is the automatic re-binding of specification variables. This is
achieved by introducing non-determinism in the automata"

This is incorrect.  Re-binding and non-determinism are orthogonal.  There
are deterministic automata that rebind values, and there are
nondeterministic automata that do not rebind values.  Tracematches and
JavaMOP (with finite automata), for example, are equally expressive to
non-deterministic TOPL automata without re-binding (see beginning).
Informally, in the setting of quantified event automata, re-binding is
equivalent to having an infinite number of quantifiers.



"I believe the paper does not clarify sufficiently how runtime checking is
performed (not self-contained)."

We respectfully disagree.  Looking at the code, which is online, will
reveal that the implementation is essentially Definition 2, Definition 6,
Section 5, and a library for handling Java bytecode.



"A similar effect to this re-binding can be achieved by simply considering
sets of objects."

Sets are a good idea.  We are, in fact, investigating their use.  Our first
step was to explore the theoretical implications.  Please skim
http://arxiv.org/abs/1209.0680 to get a rough idea of what is involved.



"Can you expand on why it is more natural to express properties as TOPL
properties than as attribute grammars with sets or with Quantified Event
Automata?"

Strictly speaking, we cannot ‘expand’ on this, because we never made such a
claim.  As a rule, we try to steer away from opinions that cannot be backed
by proofs.  However, we can mention the main ingredient that makes us feel
that TOPL properties are natural:  The concatenation of labels on a walk to
‘error’ looks very much like a small Java program that violates the property.
The same idea was used by PQL.  (We did not compare much with PQL because
its formal foundation is quite unclear to us.  But, it certainly has some
good ideas.)



"How does the overhead in your approach compare to the overhead in other
approaches for similar properties?"

We do not have an efficient implementation.  Compared to JavaMOP, which is
one of the fastest tools, our monitors take 30--40 times more time.


vim:tw=75:fo+=t:spell:
