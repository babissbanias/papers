\documentclass[preprint]{sigplanconf} % <<<

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphics}
\usepackage[latin1]{inputenc}
\usepackage{microtype}  % do not remove
\usepackage{pygmentize}
\usepackage{rgalg}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{xspace}

\usepackage[colorlinks]{hyperref} % keep it last to avoid some warnings

\RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}
\definecolor{darkred}{rgb}{0.4,0,0}
\definecolor{darkblue}{rgb}{0,0,0.4}
\definecolor{verylightgray}{rgb}{0.9,0.9,0.9}
\definecolor{lightblue}{rgb}{0,0,0.9}
% comment the next line for printing
\hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkblue}
\hypersetup{
  pdftitle={TOPL: A Language for Specifying Safety Temporal Properties of Object-Oriented Programs},
  pdfauthor={Radu Grigore and Rasmus Lerchedahl Petersen and Dino Distefano}}

\newcommand{\TPL}{TOPL}

\titlebanner{DRAFT}
\title{Dynamic Checking of Temporal Safety properties for Java}
\authorinfo{Dino Distefano \and Radu Grigore \and Rasmus Lerchedahl Petersen}{Queen Mary, University of London}{{\rm\{}ddino,rgrig,rusmus{\rm\}}@eecs.qmul.ac.uk}

% rg: I tend to give grammars in BFS order
\def\grammar#1{{
  \footnotesize
  \def\b##1{{\rm\Verb@##1@}}\def\*{$^*$}\def\?{$^?$}\def\({$($}\def\){$)$}
  \def\|{$\mid$}\def\+{$^+$}
  \smallskip
  \hbox to\hsize{\hfil\vbox{\halign{\hfil\it##&$\;::=\;$\it##\hfil&\qquad\rm##\hfil\cr#1}}\hfil}
  \smallskip
}}

\renewcommand{\sectionautorefname}{Section}
\renewcommand{\subsectionautorefname}{\sectionautorefname}

\newcommand{\note}[2]{\textcolor{gray}{[\textcolor{red}{#1}: #2]}}
%\renewcommand{\note}[2]{}
\newcommand{\rg}[1]{\note{rg}{#1}}
\newcommand{\rlp}[1]{\note{rlp}{#1}}
\newcommand{\dd}[1]{\note{dd}{#1}}
\newcommand{\dinocomment}[1]{\dd{#1}}

\newcommand{\B}{\ensuremath{\mathbb{B}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\delimitVerbatim}{\par\nobreak\smallskip\noindent}
\newcommand{\error}{\ensuremath{\textcolor{darkred}{\mathtt{error}}}\xspace}
\newcommand{\eval}[1]{[[#1]]}
\newcommand{\pattern}[1]{\ensuremath{\mathtt{\underline{#1}}}}
\newcommand{\pmap}{\rightharpoonup}
\newcommand{\set}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\start}{\ensuremath{\mathtt{start}}\xspace}
\newcommand{\verbline}[2][]{\[\text{\Verb@#2@}#1\]}

\newcommand{\functionfont}[1]{\mathit{#1}}
\newcommand{\desugar}{\functionfont{des}}
\newcommand{\enabled}{\functionfont{enabled}}

\newcommand{\codefont}[1]{\mathtt{#1}}
\newcommand{\this}{\codefont{this}}

\theoremstyle{definition}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem{remark}{Remark}
\newtheorem{notation}{Notation}

\overfullrule=5pt
\showboxdepth=10
\showboxbreadth=30
% >>>
\begin{document}
\maketitle

\begin{abstract} % <<<
In this paper we introduce a new technique for checking, at run time, temporal safety properties for Java programs.
Our technique is based on a new general specification language which is able to express fundamental properties of 
systems. The specifications are then used to instrument the program so that violations of the specification can be 
automatically detected at run time.
\end{abstract}
\category{D.2.1}{Software Engineering}{Requirements/Specifications}
\terms Languages, Verification
\keywords Safety, Temporal Properties, Object-Oriented

% >>>
\section{Introduction} % <<<

The verification community showed interest in \emph{safety temporal properties} for a long time.
Manna and Pnueli~\cite{dblp:books/daglib/0080029} provide a theoretical foundation and clearly argue why such properties are crucial.
In this article, we focus on the automatic dynamic checking of safety temporal properties on an object-oriented setting. 
One first difficulty in attacking this problem is a suitable formal specification language. Consider for 
example  Java collections. A typical property one would want to state is:
\begin{quote}
If one iterator modifies its collection, then other existing iterators of the same collection become invalid and cannot be used later.
\end{quote}
\noindent
The formalization of the above constraint is not trivial since it 
needs to keep track of {\em several objects} (at least two iterators, and one collection) and their {\em interaction}.
Although several existing specification languages for safety temporal properties of object-oriented software exist~\cite{strom1986,dblp:conf/oopsla/bierhoffa07,dblp:conf/oopsla/naeeml08,disney2011,ball2002},
we found them not entirely suitable for our goal. For this reasons we have defined  \TPL\ (\textbf{t}emporal \textbf{o}bject-oriented \textbf{p}roperty language, pronounced like `topple').
%Bierhoff and Aldrich~\cite{dblp:conf/oopsla/bierhoffa07} as well as Naeem and Lhot\'ak~\cite{dblp:conf/oopsla/naeeml08} use specification languages inspired by typestates~\cite{strom1986}.
%Specifically, Bierhoff and Aldrich~\cite{dblp:conf/oopsla/bierhoffa07} use a combination of linear logic~\cite{dblp:journals/tcs/girard87} and access permissions, while Naeem and Lhot\'ak~\cite{dblp:conf/oopsla/naeeml08} use tracematches.
%Disney et al.~\cite{disney2011} use a language based on regular grammars to specify higher-order temporal contracts.
%Finally, Ball and Rajamani~\cite{ball2002} essentially use nondeterministic aspect-oriented programming.

\TPL \ takes inspiration from several of such existing specification languages, but has  the following distinctive features:
\begin{enumerate}
\item It easily expresses relationships between several objects.
\item It is high-level and similar to diagrams used in informal explanations.
\item It has a well-defined formal semantics in terms of a specific type of automatons.
\item It is designed to be used in program analysis (both static and dynamic).
\end{enumerate}
The ability to express relations of several objects makes \TPL\ quite expressive.
Most other techniques aim at decomposing properties involving several objects into specifications that reflect the point of view of a single object.
In contrast, TOPL does not try to achieve such decomposition.
Parkinson~\cite{parkinson-iwaco2007} argues that invariants involving several objects are sometimes better than one-object invariants.
Similarly, we believe that temporal properties that naturally involve several objects are easier to reason about if they are \emph{not} decomposed.
Because TOPL is a high-level language and has formal semantics (points 2~and~3 above), it reduces the semantic gap between the intuitive notion that programmers have of various temporal constraints on their code and the precise formal description needed by verification tools for automatic checking of these constraints.

\paragraph{Checking TOPL properties.}
Having defined how to specify temporal properties in a convenient way, we then develop a technique for checking them at run-time on Java programs.
Our method involves instrumenting the Java byte code in such a way it reflects the TOPL property of interest.
Automatically checking TOPL properties is beneficial for the programmer since it relieves him/her from the burden of
inserting ad-hoc checks interspersed in the code for tracing the violation of a correct temporal behaviour.
The Java API, for example, has hand-crafted code for checking certain temporal properties (\autoref{sec:examples.steps}).
Such checks are
\begin{itemize}
\item hard to write,
\item weaved with the code that solves the actual problem, and
\item in the case of the Java API, do not provide a trace of the relevant events that lead to an error.
\end{itemize}
In contrast, dynamically checking TOPL properties  with our technique is transparent to the programmer therefore avoiding all these problems.


The paper is organized as follows. In Section~\ref{sec:examples} we start with few motivating examples.
Section~\ref{sec:syntax} gives the syntax of \TPL \ and in Section~\ref{sec:semantics} introduces its semantics.
Section~\ref{sec:dynamic} briefly explores the use of \TPL \ for run-time checking of safety properties.
Section~\ref{sec:related} discusses related work.
Finally, Section~\ref{sec:conclusions} concludes the paper and describes our plans for future work.




% >>>
\section{Running Example} \label{sec:examples} % <<<

\section{TOPL syntax and semantics}

\section{Run-time checking}
\subsection{Run-time soundness}
\dinocomment{here define the notion and show that it is impossible to achive}
\dinocomment{talk about our strategy}
\subsection{Checker}
\subsection{Byte code instrumentation}

\section{Experimental Results}

\dinocomment{experiments: TOMCAT, ANT, Eclipse and Dacapo benchmarks}

% >>>
\section{Related Work}\label{sec:related} %<<<
Our work is based on the concept of typestate~\cite{strom1986} originally developed for imperative programs and extends this fundamental concept by integrating notions typical of object-oriented programs. 
We are certainly not the first in doing this: there are several extensions of typestate to object-oriented programming in the literature.
A modular static verification method for typestate protocols is introduces in~\cite{dblp:conf/oopsla/bierhoffa07}. 
The specification method is based on linear logic and relations among objects in the protocol are monitored by a tailored system of permissions. 
The method is highly modular and presumably efficient. The specification of the interactions among objects by means of permissions adds an extra level of machinery which increases the gap between the intuitive protocol description and its formalization. Similarly~\cite{deline2004,dblp:conf/sigsoft/BierhoffA05} provide a mean to specify typestate properties that belong to a single object. The specified properties are reminiscent of contracts or pre/post-conditions for methods and
can deal with inheritance.
In~\cite{dblp:conf/issta/FinkYDRG06} the authors present sound verification techniques for typestate properties of Java  programs.
Their approach is divided in several stages with different verifiers varying for cost and precision.
In the early stages efficient but imprecise analyses are employed whereas
more expensive and precise techniques are then progressively employed in later stages.
Every stage focuses on verifying only the parts of the code that previous stages failed to verify.
It is likely that our TOPL language could be fruitfully combined with their analysis technique.

An automaton-based formalism for specifying properties of software interfaces were introduced in~\cite{dblp:conf/sigsoft/AlfaroH01} . 
This language aims at capturing assumptions about the order in which the methods of a component are called and the order in which the component calls external method.
In contrast to \TPL, this formalism is mainly used to check the compatibility of the interfaces of two components and it is designed to be applied at  model level rather than code level. A specification language for interface checking aimed to C programs (called SLIC) is introduced in~\cite{ball2002}.  
Differences between SLIC and \TPL \ include: the use (in SLIC) of
non-determinism to encode universal quantification of dynamically allocated data, and the  ability to have complex code in the automaton transitions. 
\TPL \ specifications naturally express universally quantified
properties over data structures and for computability reasons,  we
have chosen to limit the  actions performed during automaton transitions. 
Simple SLIC specifications are verified by  the SLAM verifier~\cite{dblp:conf/cav/ballr01}.
While SLAM specialises on device drivers and checks client conformance rather than full protocols, 
very general specifications of object-oriented program behaviour can be given in JML~\cite{jml} and Spec$\sharp$~\cite{DBLP:journals/jot/BarnettDFLS04}. However the latter two languages focus on class specifications and do not have temporal features.

In~\cite{disney2011} contracts are used to express legal traces of
programs in a functional language with references. The contracts
specify traces as regular expressions over calls and returns and so
look similar to our automatons, if for a quite different
setting. Here, the specifications are function-centered, though, and
again, capturing inter object relations seems somewhat awkward.

\dinocomment{Add more on dynamic checks and byte code instrumentation}

% >>>
\section{Conclusions and Future Work}\label{sec:conclusions} %<<<

\paragraph{Future work}
In the future, we intend to make use of separation logic~\cite{reynolds2002} to deal with the heavy use of the heap and aliasing in object-oriented software. Moreover, we aim at developing static analysis techniques for \TPL \ properties of Java programs using the jStar framework~\cite{DBLP:conf/oopsla/DistefanoP08}.
This will require investigating suitable abstraction techniques for obtaining meaningful and precise over-approximations of the state space of the programs.
Finally, we intend to develop a tailored bi-abduction inference technology~\cite{dblp:conf/popl/CalcagnoDOY09} which would help with scalability of the analysis.
\dinocomment{Mention that we want to at least reach runtime soundness with abstractions}


%>>>

\softraggedright
\bibliographystyle{abbrvnat}
\bibliography{safety}
\end{document}
% vim:spell errorformat=%f\:%l-%m,%f\:%l\:%m,%f\:%m
% vim:fmr=<<<,>>>:
