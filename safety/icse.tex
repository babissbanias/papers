\documentclass[10pt, conference, compsocconf]{IEEEtran} % <<<

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphics}
\usepackage[latin1]{inputenc}
\usepackage{microtype}  % do not remove
\usepackage{pygmentize}
\usepackage{rgalg}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{xspace}

\usepackage[colorlinks]{hyperref} % keep it last to avoid some warnings

\RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}
\definecolor{darkred}{rgb}{0.4,0,0}
\definecolor{darkblue}{rgb}{0,0,0.4}
\definecolor{verylightgray}{rgb}{0.9,0.9,0.9}
\definecolor{lightblue}{rgb}{0,0,0.9}
% comment the next line for printing
\hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkblue}
\hypersetup{
  pdftitle={TOPL: A Language for Specifying Safety Temporal Properties of Object-Oriented Programs},
  pdfauthor={Radu Grigore and Rasmus Lerchedahl Petersen and Dino Distefano}}

\newcommand{\TPL}{TOPL}

%\titlebanner{DRAFT}
\title{Dynamic Checking of Temporal Safety properties for Java}
\author{\IEEEauthorblockN{Dino Distefano}
\IEEEauthorblockA{Queen Mary University of London\\
ddino@eecs.qmul.ac.uk}
\and
\IEEEauthorblockN{Radu Grigore}
\IEEEauthorblockA{Queen Mary University of London\\
 rgrig@eecs.qmul.ac.uk}
 \and
\IEEEauthorblockN{Rasmus Lerchedahl Petersen}
\IEEEauthorblockA{Queen Mary University of London\\
 rusmus@eecs.qmul.ac.uk}
}

%\title{Dynamic Checking of Temporal Safety properties for Java}
%\author{Dino Distefano \and Radu Grigore \and Rasmus Lerchedahl Petersen}{Queen Mary, University of London}{{\rm\{}ddino,rgrig,rusmus{\rm\}}@eecs.qmul.ac.uk}

% rg: I tend to give grammars in BFS order
\def\grammar#1{{
  \footnotesize
  \def\b##1{{\rm\Verb@##1@}}\def\*{$^*$}\def\?{$^?$}\def\({$($}\def\){$)$}
  \def\|{$\mid$}\def\+{$^+$}
  \smallskip
  \hbox to\hsize{\hfil\vbox{\halign{\hfil\it##&$\;::=\;$\it##\hfil&\qquad\rm##\hfil\cr#1}}\hfil}
  \smallskip
}}

\renewcommand{\sectionautorefname}{Section}
\renewcommand{\subsectionautorefname}{\sectionautorefname}

\newcommand{\note}[2]{\textcolor{gray}{[\textcolor{red}{#1}: #2]}}
%\renewcommand{\note}[2]{}
\newcommand{\rg}[1]{\note{rg}{#1}}
\newcommand{\rlp}[1]{\note{rlp}{#1}}
\newcommand{\dd}[1]{\note{dd}{#1}}
\newcommand{\dinocomment}[1]{\dd{#1}}

\newcommand{\B}{\ensuremath{\mathbb{B}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\delimitVerbatim}{\par\nobreak\smallskip\noindent}
\newcommand{\error}{\ensuremath{\textcolor{darkred}{\mathtt{error}}}\xspace}
\newcommand{\eval}[1]{[[#1]]}
\newcommand{\pattern}[1]{\ensuremath{\mathtt{\underline{#1}}}}
\newcommand{\pmap}{\rightharpoonup}
\newcommand{\set}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\start}{\ensuremath{\mathtt{start}}\xspace}
\newcommand{\verbline}[2][]{\[\text{\Verb@#2@}#1\]}

\newcommand{\functionfont}[1]{\mathit{#1}}
\newcommand{\desugar}{\functionfont{des}}
\newcommand{\enabled}{\functionfont{enabled}}

\newcommand{\codefont}[1]{\mathtt{#1}}
\newcommand{\this}{\codefont{this}}

\theoremstyle{definition}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem{remark}{Remark}
\newtheorem{notation}{Notation}

%\overfullrule=5pt
%\showboxdepth=10
%\showboxbreadth=30
% >>>
\begin{document}
\maketitle

\begin{abstract} % <<<
In this paper we introduce a new technique for checking, at run time, temporal safety properties for Java programs.
Our technique is based on a new general specification language which is able to express fundamental properties of 
systems. The specifications are then used to instrument the program so that violations of the specification can be 
automatically detected at run time.
\end{abstract}
\begin{IEEEkeywords}
Safety, Temporal Properties, Object-Oriented, Dynamic Checking
\end{IEEEkeywords}

%\category{D.2.1}{Software Engineering}{Requirements/Specifications}
%\terms Languages, Verification
%\keywords Safety, Temporal Properties, Object-Oriented

% >>>
\section{Introduction} % <<<

The verification community showed interest in \emph{safety temporal properties} for a long time.
Manna and Pnueli~\cite{dblp:books/daglib/0080029} provide a theoretical foundation and clearly argue why such properties are crucial.
In this article, we focus on the automatic dynamic checking of safety temporal properties on an object-oriented setting. 
One first difficulty in attacking this problem is a suitable formal specification language. Consider for 
example  Java collections. A typical property one would want to state is:
\begin{quote}
If one iterator modifies its collection, then other existing iterators of the same collection become invalid and cannot be used later.
\end{quote}
\noindent
The formalization of the above constraint is not trivial since it 
needs to keep track of {\em several objects} (at least two iterators, and one collection) and their {\em interaction}.
Although several existing specification languages for safety temporal properties of object-oriented software exist~\cite{strom1986,dblp:conf/oopsla/bierhoffa07,dblp:conf/oopsla/naeeml08,disney2011,ball2002},
we found them not entirely suitable for our goal. For this reasons we have defined  \TPL\ (\textbf{t}emporal \textbf{o}bject-oriented \textbf{p}roperty language, pronounced like `topple').
%Bierhoff and Aldrich~\cite{dblp:conf/oopsla/bierhoffa07} as well as Naeem and Lhot\'ak~\cite{dblp:conf/oopsla/naeeml08} use specification languages inspired by typestates~\cite{strom1986}.
%Specifically, Bierhoff and Aldrich~\cite{dblp:conf/oopsla/bierhoffa07} use a combination of linear logic~\cite{dblp:journals/tcs/girard87} and access permissions, while Naeem and Lhot\'ak~\cite{dblp:conf/oopsla/naeeml08} use tracematches.
%Disney et al.~\cite{disney2011} use a language based on regular grammars to specify higher-order temporal contracts.
%Finally, Ball and Rajamani~\cite{ball2002} essentially use nondeterministic aspect-oriented programming.

\TPL \ takes inspiration from several of such existing specification languages, but has  the following distinctive features:
\begin{enumerate}
\item It easily expresses relationships between several objects.
\item It is high-level and similar to diagrams used in informal explanations.
\item It has a well-defined formal semantics in terms of a specific type of automatons.
\item It is designed to be used in program analysis (both static and dynamic).
\end{enumerate}
The ability to express relations of several objects makes \TPL\ quite expressive.
Most other techniques aim at decomposing properties involving several objects into specifications that reflect the point of view of a single object.
In contrast, TOPL does not try to achieve such decomposition.
Parkinson~\cite{parkinson-iwaco2007} argues that invariants involving several objects are sometimes better than one-object invariants.
Similarly, we believe that temporal properties that naturally involve several objects are easier to reason about if they are \emph{not} decomposed.
Because TOPL is a high-level language and has formal semantics (points 2~and~3 above), it reduces the semantic gap between the intuitive notion that programmers have of various temporal constraints on their code and the precise formal description needed by verification tools for automatic checking of these constraints.

\paragraph{Checking TOPL properties.}
Having defined how to specify temporal properties in a convenient way, we then develop a technique for checking them at run-time on Java programs.
Our method involves instrumenting the Java byte code in such a way it reflects the TOPL property of interest.
Automatically checking TOPL properties is beneficial for the programmer since it relieves him/her from the burden of
inserting ad-hoc checks interspersed in the code for tracing the violation of a correct temporal behaviour.
The Java API, for example, has hand-crafted code for checking certain temporal properties (\autoref{sec:examples.steps}).
Such checks are
\begin{itemize}
\item hard to write,
\item weaved with the code that solves the actual problem, and
\item in the case of the Java API, do not provide a trace of the relevant events that lead to an error.
\end{itemize}
In contrast, dynamically checking TOPL properties  with our technique is transparent to the programmer therefore avoiding all these problems.

\dinocomment{below to be done more precisely when the paper is more concrete}
The paper is organized as follows. In Section~\ref{sec:examples} we start with few motivating examples.
Section~\ref{sec:syntax} gives the syntax of \TPL \ and in Section~\ref{sec:semantics} introduces its semantics.
Section~\ref{sec:dynamic} briefly explores the use of \TPL \ for run-time checking of safety properties.
Section~\ref{sec:related} discusses related work.
Finally, Section~\ref{sec:conclusions} concludes the paper and describes our plans for future work.




% >>>
\section{TOPL by Examples} \label{sec:examples} % <<<
In this section we introduce TOPL in an informal way by means of examples; in Section~\ref{sec:syntax} we will give a formal development of the language.

The first example (\autoref{sec:examples.steps}) uses a large part of \TPL\null.
Each execution step introduces a few new concepts.
The other examples (Sections~\ref*{sec:examples.iterators}--\ref*{sec:examples.ho}) illustrate TOPL expressiveness.

%\rg{TODO: Property names are not consistent:
%Should they read like an error message?
%Should they say what is good or what is bad?}

\subsection{Iterators Step by Step} \label{sec:examples.steps} % <<<
Consider the informal safety property from the introduction. It can be better restated as:
\begin{quote}
\emph{Modifying a collection through an iterator invalidates other iterators for the same collection}.
\end{quote}
\noindent
The last statement in \autoref{fig:first.java} violates the statements above, therefore throwing an exception.
There are two iterators on the same collection, one of them modifies the collection, and this invalidates the other iterator.
Such properties are often explained using diagrams~\cite{dblp:journals/scp/FieldGRY05,dblp:conf/issta/FinkYDRG06,dblp:conf/oopsla/bierhoffa07,dblp:conf/oopsla/naeeml08,dblp:conf/sigsoft/boddenlh08,dblp:conf/ecoop/bierhoffba09}.
The diagrams are sometimes precise, but not expressive enough~\cite{dblp:journals/scp/FieldGRY05,dblp:conf/issta/FinkYDRG06};
the diagrams are sometimes expressive, but not precise enough~\cite{dblp:conf/oopsla/bierhoffa07,dblp:conf/oopsla/naeeml08,dblp:conf/sigsoft/boddenlh08,dblp:conf/ecoop/bierhoffba09}.
\autoref{fig:first.diagram}, on the other hand, captures precisely a temporal property involving three interacting objects.
\autoref{fig:first.topl} describes the same property in (the textual form of) TOPL, and is (clearly) isomorphic to the diagram of~\autoref{fig:first.diagram}.

In a TOPL property, vertices have identifiers (\texttt{start}, \texttt{one}, \texttt{two}, \dots);
transitions have labels ($\pattern I:=\pattern C.\mathtt{iterator}()$, \dots).
There are two special vertices: \start, from where the execution begins; and \error, where the execution ends.
Labels capture, roughly, the shape of statements that enable the corresponding transition.

\begin{figure} % first example <<<
\include{IncorrectIteratorUse}
\caption{A first example: Java code}
\label{fig:first.java}
\end{figure}
\begin{figure}
\begin{Verbatim}
using prefix java.util.Collection
using prefix java.util.Iterator
\end{Verbatim}
\par\medskip
\begin{tikzpicture}
  \def\x{2.5}
  \tikzset{vertex/.style={draw,circle,inner sep=1pt}}
  \tikzset{transition/.style={->,>=latex}}
  \tikzset{every label/.style={gray}}
  \node[vertex] (start) at (0,0) [label=left:\texttt{start}] {};
  \node[vertex] (one) at (0,-1) [label=left:\texttt{one}] {};
  \node[vertex] (two) at (0,-2) [label=below:\texttt{two}] {};
  \node[vertex] (xBad) at (1*\x,-2.5) [label=right:\texttt{xBad}] {};
  \node[vertex] (yBad) at (-1*\x,-2.5) [label=left:\texttt{yBad}] {};
  \node[vertex,fill=darkred] (error) at (0,-3) [label=below:\textcolor{darkred}{\texttt{error}}] {};
  \draw[transition] (0,0.5)--(start);
  \draw[transition] (start)--node[right]{$\pattern X:=\pattern C.\mathtt{iterator}()$} (one);
  \draw[transition] (one) .. controls +(30:1cm) and +(-30:1cm) .. node[right]{$*$} (one);
  \draw[transition] (one)--node[right]{$\pattern Y:=\pattern c.\mathtt{iterator}()$} (two);
  \draw[transition] (two) -- node[sloped,above]{$\pattern y.\mathtt{remove}()$} (xBad);
  \draw[transition] (two)--node[sloped,above]{$\pattern x.\mathtt{remove}()$} (yBad);
  \draw[transition] (xBad)--node[sloped,below]{$\mathtt{call}\;\pattern x.{*}[*]$} (error);
  \draw[transition] (yBad)--node[sloped,below]{$\mathtt{call}\;\pattern y.{*}[*]$} (error);
\end{tikzpicture}
\caption{A first example: Diagram of safety property}
\label{fig:first.diagram}
\end{figure}
\begin{figure}
\begin{Verbatim}[commandchars=\\\{\}]
property InvalidateOtherIterators
  using prefix java.util.Collection
  using prefix java.util.Iterator
  start -> one:  \pattern{X} := \pattern{C}.iterator()
  one -> one:    *
  one -> two:    \pattern{Y} := \pattern{c}.iterator()
  two -> yBad:   \pattern{x}.remove()
  two -> xBad:   \pattern{y}.remove()
  yBad -> error: call \pattern{y}.*[*]
  xBad -> error: call \pattern{x}.*[*]
\end{Verbatim}
\caption{A first example: Safety property}
\label{fig:first.topl}
\end{figure}
\begin{figure}
{\def\s#1{\text{\Verb@#1@}}
 \def\m#1{\PY{n+na}{#1}}
 \def\t#1{\mathtt{#1}}
\begin{align*}
&\{\;(\start,[])\;\} \\
&\s{Iterator<Integer> i = c.\m{iterator}();} \\
&\text{assume {\tt c} holds $1$, and {\tt i} holds $2$ } \\
& \begin{aligned}
  \{\;&(\start,[]),\\
      &(\t{one},[c:1,x:2])\;\}
  \end{aligned}\\
&\s{Iterator<Integer> j = c.\m{iterator}();} \\
&\text{assume {\tt j} holds $3$} \\
& \begin{aligned}
  \{\;&(\start,[]),\\
      &(\t{one},[c:1,x:2]),\\
      &(\t{one},[c:1,x:3]),\\
      &(\t{two},[c:1,x:2,y:3])\;\}
  \end{aligned}\\
&\s{i.\m{next}();} \\
& \begin{aligned}
  \{\;&(\start,[]),\\
      &(\t{one},[c:1,x:2]),\\
      &(\t{one},[c:1,x:3]),\\
      &(\t{two},[c:1,x:2,y:3])\;\}
  \end{aligned}\\
&\s{i.\m{remove}();} \\
& \begin{aligned}
  \{\;&(\start,[]),\\
      &(\t{one},[c:1,x:2]),\\
      &(\t{one},[c:1,x:3]),\\
      &(\t{yBad},[c:1,x:2,y:3])\;\}
  \end{aligned}\\
&\s{j.\m{next}()} \\
& \begin{aligned}
  \{\;&(\start,[]),\\
      &(\t{one},[c:1,x:2]),\\
      &(\t{one},[c:1,x:3]),\\
      &(\error,[c:1,x:2,y:3])\;\}
  \end{aligned}\\
\end{align*}}
\caption{A first example: Running step by step}
\label{fig:first.steps}
\end{figure} % >>>

\autoref{fig:first.steps} shows an execution of the program and of an automaton for the property \texttt{InvalidateOtherIterators}.
The lines \{in curly brackets\} describe the state of the automaton;
the lines in \texttt{monotype} show the statements that execute;
the other lines are comments.
At a given moment, the automaton has a set of active states.
A state is a pair of a vertex and a store.
The store is a memory that holds (automaton) variables.
Technically, it is a finite partial map from variables to values.
(A partial finite map is sometimes called a \emph{dictionary}.)

\begin{notation}
We write $[k_1:v_1,k_2:v_2]$ for the finite partial map that maps key~$k_1$ to value~$v_1$, and key~$k_2$ to value~$v_2$.
The empty map is denoted by~$[]$.
\end{notation}

The automaton has variables $x$,~$y$, and~$c$.
At vertex \texttt{one} the variables $x$~and~$c$ are initialized;
at vertex \texttt{two} the variables $x$,~$y$, and~$c$ are initialized.
Being at vertex \texttt{one} means that $x$~is an iterator for~$c$;
being at vertex \texttt{two} means that $x$~and~$y$ are two iterators for the same collection~$c$.
There is a program variable~\Verb@c@ and an automaton variable~$c$.
The same name was chosen because the two variables always hold the same value in this example.
In general, however, program variables and automaton variables live in different name-spaces, and may hold different values.

\begin{notation}
Program variables are typeset in \Verb@monotype@ (\Verb@c@,~\Verb@i@,~\Verb@j@).
Automaton variables are typeset in \textit{italics} ($c$,~$x$,~$y$).
Program variables appear in the program;
automaton variables do \emph{not} appear in the property.
Instead, automaton variable \emph{patterns} appear in the property, and they are typeset in \texttt{\underline{underlined monotype}} (\pattern c,~\pattern C, \pattern x, \pattern X, \pattern y,~\pattern Y).
\end{notation}

As it will become apparent below, the interaction between patterns and automatons' memory is as follows: uppercase patterns write to the automaton memory, and lowercase patterns read from the automaton memory and act as a guard on the transition.

\paragraph{Step~1.}

Initially, only the state $(\start,[])$ is active.
The outgoing transition of vertex \start is labeled by \[\pattern X:=\pattern{C}.\mathtt{iterator}()\] and the first executed statement is \verbline[.]{i = c.\PY{n+na}{iterator}()}
A method call matches a label when
\begin{itemize}
\item[(a)] the called method matches the method pattern, and
\item[(b)] the program values match their corresponding patterns.
\end{itemize}
By definition, any value matches an Uppercase pattern.
Here, the values of \Verb@i@~and~\Verb@c@ trivially match the patterns \pattern X~and~\pattern C.
The method itself also matches the method pattern, but for a slightly more complicated reason than it appears.
For simplicity, we ignore argument types and identify Java methods only by their fully qualified name and their arity.
The called method \texttt{iterator} is in the class \texttt{ArrayList} and has arity~$1$.
We identify it as follows.
\verbline{java.lang.ArrayList.iterator[1]}
Without \texttt{using prefix} directives, the method pattern would be \Verb@iterator[1]@.
With the directives, however, the pattern is the following.
\begin{align*}
&\text{\Verb@java.util.Collection.iterator[1]@} \\
&\text{\Verb@java.util.Iterator.iterator[1]@}
\end{align*}
It means that these two methods \emph{and} all those that override them match.
Here, \texttt{ArrayList} implements \texttt{Collection}.

All conditions are met to enable the transition from \start to \texttt{one}.
When the transition is performed the values that matched \pattern X~and~\pattern C are written in the automaton variables $x$~and~$c$.
For concreteness, let us assume these values are $1$~and~$2$.
After the transition is performed, the state $(\mathtt{one},[c:1,x:2])$ is active.
The state $(\start,[])$ remains active because the implicit transition \verbline{start -> start: *} is also enabled and performed.

\paragraph{Step~2.}
For the second step, the statement to be executed is \verbline[.]{j = c.\PY{n+na}{iterator}()}
Now we need to consider the two active states \[\{(\start,[])\quad\text{and}\quad(\texttt{one},[c:1,x:2])\}\] in turn.
For $(\start,[])$ the same reasoning as for step 1 holds, so the states $(\start,[])$ and $(\mathtt{one},[c:1,x:3])$ are active after step~2.
Note that now the automaton variable~$x$ remembers the value of the program variable~{\tt j}.
For $(\texttt{one},[c:1,x:2])$ we look at the transitions outgoing from vertex {\tt one}.
\begin{align*}
&\text{\Verb@one -> one: *@} \\
&\text{\Verb@one -> two: \pattern Y := \pattern c.iterator()@}
\end{align*}
The first of these transitions is always enabled, and performing it keeps states with vertex \texttt{one} active.
The second of these transitions has two patterns, \pattern Y~and~\pattern c.
The uppercase pattern~\pattern Y always matches;
the lowercase pattern \pattern c matches only the value held by the automaton variable~$c$.
In this case, the automaton variable~$c$ was set in the previous step to the value of the program variable~\texttt{c}.
Therefore, the transition from~\Verb@one@ to~\Verb@two@ is performed and the state $(\mathtt{two},[c:1,x:2,y:3])$ is activated.

\paragraph{Step~3.}

The third step involves the statement
\[\text{\Verb+\PY{n}{i}\PY{o}{.}\PY{n+na}{next}\PY{o}{(}\PY{o}{)}\PY{o}{;}+}\]
which matches no label of outgoing transitions of the currently active vertices (that is, \start, {\tt one}, and {\tt  two}).
Therefore, although the program proceeds, the set of active states of the automaton remains unchanged.

\paragraph{Step~4.}

In the fourth step, the transition $\texttt{two}\to\texttt{yBad}$ is performed.
Notice that the pattern $\pattern{x}.\mathtt{remove}()$ does not have a left-hand side, which simply means that the returned value is irrelevant for this transition.
The states corresponding to vertices \start and {\tt one} remain unchanged, because their outgoing transitions are disabled.
However,  the outgoing transition of state {\tt two} is enabled, and therefore {\tt yBad} becomes active.

\paragraph{Step~5.}

For the fifth and final step, the statement to be executed is \verbline[.]{j.\PY{n+na}{next}()}
The label of the outgoing transition  \[\mathtt{call}\;\pattern{y}.{*}[*]\] of the active state $(\texttt{yBad},[c:1,x:2,y:3]),$
has two distinguishing features: the~$*$ as a method name and the tag \texttt{call}.
As before, in order to match the method name, the following prefixes are prepended  
\begin{align*}
&\text{\Verb@java.util.Collection.*[*]@} \\
&\text{\Verb@java.util.Iterator.*[*]@}
\end{align*}
Then the $*$s are expanded, taking into account the \texttt{CLASSPATH}.
We have a match because the expansion \verbline{java.util.Iterator.next} is overridden by the method that is actually called.

The tag {\tt call} is used when we want the automaton to take a transition precisely at call-time of a method invocation.
The automaton expresses that a call to one of {\tt j}'s methods while vertex \texttt{yBad} is active constitutes an error.
Notice that this is different from a label like $\pattern X:=\pattern C.\mathtt{iterator}()$ which may match only after the return value is known.

\medskip
The execution we stepped through reaches the \error vertex, so we conclude that the property is violated.
Notice that in order to find a counterexample we need to keep track of the relation between several objects, in particular that iterators {\tt i} and {\tt j} are for the same collection {\tt c}.

% >>>
\subsection{More on Iterators} \label{sec:examples.iterators} % <<<

Other interesting properties of iterators~\cite{dblp:conf/oopsla/naeeml08,dblp:conf/sigsoft/boddenlh08,haack2009} are also easy to express in TOPL\null.

\medskip\emph{Modifying a collection invalidates all its existent iterators:}
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
property ModificationInvalidatesIterators
  using prefix java.util.Collection
  using prefix java.util.Iterator
  start -> iterating:    \pattern{I} := \pattern{C}.iterator()
  iterating -> modified: \pattern{c}.add(*), \pattern{c}.remove(*)
  modified -> error:     call \pattern{i}.*[*]
\end{Verbatim}
\delimitVerbatim
This property should list all the methods of \textit{Collection} that mutate it.
If classes that implement \textit{Collection} add mutating methods, then those should be included as well.
This abstraction leak is intrinsic to Java where sub-classing is not sub-typing.

\medskip\emph{Iterators should advance only if they are not exhausted:}
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
property UnsafeIteratorNext
  using prefix java.util.Collection
  using prefix java.util.Iterator
  start -> iterating:        \pattern{I} := *.iterator()
  iterating -> notExhausted: \pattern{true} := \pattern{i}.hasNext()
  notExhausted -> iterating: \pattern{i}.next()
  iterating -> error:        \pattern{i}.next()
\end{Verbatim}
\delimitVerbatim
The transition from \Verb@iterating@ to \Verb@notExhausted@ is enabled when \Verb@hasNext@ returns \Verb@true@.
In general, Java literals act as guards on transitions.

\medskip\emph{Method \Verb@remove@ may only be called after \Verb@next@:}
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
property RemoveBeforeNext
  using prefix java.util.Collection
  using prefix java.util.Iterator
  start -> created: \pattern{I} := *.iterator()
  created -> ok:    \pattern{i}.next()
  created -> error: \pattern{i}.remove()
\end{Verbatim}
\delimitVerbatim
TOPL is designed to track properties involving multiple objects.
However, properties involving a single object are also easy to express.
The vertex \Verb@ok@ is not special.
The purpose of the transition going to \Verb@ok@ is to deactivate the state with vertex \Verb@created@.

\medskip
We have now seen four properties of iterators.
Each of the previous TOPL properties corresponds to one English sentence.

\dinocomment{Maybe we need to add also the other example of the paper.}

\section{TOPL syntax and semantics}



\section{Run-time checking}
\subsection{Run-time soundness}
\dinocomment{here define the notion and show that it is impossible to achive}
\dinocomment{talk about our strategy}
\subsection{Checker}
\subsection{Byte code instrumentation}

\section{Experimental Results}

\dinocomment{experiments: TOMCAT, ANT, Eclipse and Dacapo benchmarks}

% >>>
\section{Related Work}\label{sec:related} %<<<
Our work is based on the concept of typestate~\cite{strom1986} originally developed for imperative programs and extends this fundamental concept by integrating notions typical of object-oriented programs. 
We are certainly not the first in doing this: there are several extensions of typestate to object-oriented programming in the literature.
A modular static verification method for typestate protocols is introduces in~\cite{dblp:conf/oopsla/bierhoffa07}. 
The specification method is based on linear logic and relations among objects in the protocol are monitored by a tailored system of permissions. 
The method is highly modular and presumably efficient. The specification of the interactions among objects by means of permissions adds an extra level of machinery which increases the gap between the intuitive protocol description and its formalization. Similarly~\cite{deline2004,dblp:conf/sigsoft/BierhoffA05} provide a mean to specify typestate properties that belong to a single object. The specified properties are reminiscent of contracts or pre/post-conditions for methods and
can deal with inheritance.
In~\cite{dblp:conf/issta/FinkYDRG06} the authors present sound verification techniques for typestate properties of Java  programs.
Their approach is divided in several stages with different verifiers varying for cost and precision.
In the early stages efficient but imprecise analyses are employed whereas
more expensive and precise techniques are then progressively employed in later stages.
Every stage focuses on verifying only the parts of the code that previous stages failed to verify.
It is likely that our TOPL language could be fruitfully combined with their analysis technique.

An automaton-based formalism for specifying properties of software interfaces were introduced in~\cite{dblp:conf/sigsoft/AlfaroH01} . 
This language aims at capturing assumptions about the order in which the methods of a component are called and the order in which the component calls external method.
In contrast to \TPL, this formalism is mainly used to check the compatibility of the interfaces of two components and it is designed to be applied at  model level rather than code level. A specification language for interface checking aimed to C programs (called SLIC) is introduced in~\cite{ball2002}.  
Differences between SLIC and \TPL \ include: the use (in SLIC) of
non-determinism to encode universal quantification of dynamically allocated data, and the  ability to have complex code in the automaton transitions. 
\TPL \ specifications naturally express universally quantified
properties over data structures and for computability reasons,  we
have chosen to limit the  actions performed during automaton transitions. 
Simple SLIC specifications are verified by  the SLAM verifier~\cite{dblp:conf/cav/ballr01}.
While SLAM specialises on device drivers and checks client conformance rather than full protocols, 
very general specifications of object-oriented program behaviour can be given in JML~\cite{jml} and Spec$\sharp$~\cite{DBLP:journals/jot/BarnettDFLS04}. However the latter two languages focus on class specifications and do not have temporal features.

In~\cite{disney2011} contracts are used to express legal traces of
programs in a functional language with references. The contracts
specify traces as regular expressions over calls and returns and so
look similar to our automatons, if for a quite different
setting. Here, the specifications are function-centered, though, and
again, capturing inter object relations seems somewhat awkward.

\dinocomment{Add more on dynamic checks and byte code instrumentation}

% >>>
\section{Conclusions and Future Work}\label{sec:conclusions} %<<<

\paragraph{Future work}
In the future, we intend to make use of separation logic~\cite{reynolds2002} to deal with the heavy use of the heap and aliasing in object-oriented software. Moreover, we aim at developing static analysis techniques for \TPL \ properties of Java programs using the jStar framework~\cite{DBLP:conf/oopsla/DistefanoP08}.
This will require investigating suitable abstraction techniques for obtaining meaningful and precise over-approximations of the state space of the programs.
Finally, we intend to develop a tailored bi-abduction inference technology~\cite{dblp:conf/popl/CalcagnoDOY09} which would help with scalability of the analysis.
\dinocomment{Mention that we want to at least reach runtime soundness with abstractions}


%>>>

%\softraggedright
\bibliographystyle{IEEEtran}
\bibliography{safety}
\end{document}
% vim:spell errorformat=%f\:%l-%m,%f\:%l\:%m,%f\:%m
% vim:fmr=<<<,>>>:
