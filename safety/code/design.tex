\def\para #1.{\noindent{\it#1.\enspace}}

This file contains notes written before the implementation of various tricky parts.
Notes are in chronological order (oldest first) and there is no requirement for a note to relate to previous ones.
This is mostly a historical document, so there is no promise that notes are kept up to date when the implementation changes.

\beginsection Desugaring of call--return transitions (201106) % <<<

\para Background.
The automata observe two types of events in the program, method calls and method returns.
Sometimes, however, it is convenient for the user to think of a (call, return) pair as an atomic event.
For example, a transition labeled $I:=C.{\it iterator}()$ refers to both the call and the return of the method {\it iterator}.
The user can tag a transition with {\it call\/} or {\it return\/} to say which type of event may trigger it.
If no tag is present then the transition is said to be a call--return transition.
To deal with these transitions we must either enhance the semantics or describe how to desugar them.
I prefer to keep the basic semantics simple.

Each call or return transition has a guard and an action:
The guard examines the event and decides if the transition should be performed and the action writes to the automaton memory.
$$x\to y:\; (g, a)$$
Intuitively, a call--return transition has two guards and two actions.
$$x\to y:\; (g,a); (g',a')$$
For a sequence $e;e'$ of events, if $g(e)$ is true then $a$ is applied and then $g'(e')$~is evaluated.
If it is false then $a$~is undone and the call--return transition is not performed.
This illustrates the first problem:
How to undo an action?
The solution is to exploit nondeterminism.
$$\eqalign{
&x\to\langle xy\rangle:\; (g, a) \cr
&\langle xy\rangle\to y:\; (g', a') \cr
&x\to[x]:\; (g, 0) \cr
&[x]\to x:\; (\lnot g', 0) \cr
}$$
The action~$0$ means ``do nothing.''
If $g(e)$~is true then the execution goes both to~$\langle xy\rangle$ with a modified store and to~$[x]$ with the old store.

The second problem is how to handle multiple outgoing transitions.
Without call--return transitions, the interpreter still needs to consider all the outgoing transitions of a node at once:
The source remains active if and only if {\it no\/} guard of an outgoing transition matches.
Consider the following configuration to desugar.
$$\eqalign{
&x\to y:\; (g, a) \cr
&x\to y_0:\; (g_0,a_0); (g'_0,a'_0) \cr
&x\to y_1:\; (g_1,a_1); (g'_1,a'_1) \cr
}$$
A possible desugaring is the following.
$$\eqalign{
&x\to y:\; (g, a) \cr
&x\to\langle x_0\rangle:\; (g_0,a_0) \cr
&x\to\langle x_1\rangle:\; (g_1,a_1) \cr
&\langle x_0\rangle\to y_0:\; (g'_0,a'_0) \cr
&\langle x_1\rangle\to y_1:\; (g'_1,a'_1) \cr
&\langle x_0\rangle\to{\it stuck}:\; (\lnot g'_0, 0) \cr
&\langle x_1\rangle\to{\it stuck}:\; (\lnot g'_1, 0) \cr
&x\to[x_{01}]:\; (\lnot g \land \lnot g_1 \land g_0, 0) \cr
&x\to[x_{10}]:\; (\lnot g \land g_1 \land\lnot g_0, 0) \cr
&x\to[x_{11}]:\; (\lnot g \land g_1\land g_0), 0) \cr
&[x_{01}]\to x:\; (\lnot g'_0, 0) \cr
&[x_{10}]\to x:\; (\lnot g'_1, 0) \cr
&[x_{11}]\to x:\; (\lnot g'_1 \land\lnot g'_0, 0) \cr
}$$
The node~{\it stuck\/} is some node with no outgoing transition.
If there are $n$~outgoing call--return transitions from~$x$, then the desugaring contains $n$~$\langle$intermediate states$\rangle$ and $2^n-1$~[states responsible for returning to~$x$], should the second guard not match.
The exponential grow is worrisome, of course.
An implementation focused on efficiency must either use a different desugaring or must implement call--return transition semantics directly in the interpreter.
However, we are now focused on correctness, not efficiency.

Finally, we may wish to make the desugaring safer.
Currently, a call--return transition with guards $g$~and~$g'$ is not performed if~$g(e)$ but not~$g'(e')$.
However, we may want to warn the user if $g'$ fails because $e'$ is not a return event or not an event related to the same method.
In general, the current desugaring scheme is agnostic of the {\it call\/} and {\it return\/} event types.
(ALSO:
Consider a recursive method.
The scheme so far may only fire for the base case and will always silently not match for the recursive case.
In other words, only the innermost call to a recursive call may match.
In the `safe' version of the desugaring, such recursive calls will cause the automaton to signal.)


% >>>

\bye

% vim:wrap:linebreak:fmr=<<<,>>>:nosi:spell:
