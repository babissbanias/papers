\documentclass[preprint]{sigplanconf} % <<<

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphics}
\usepackage[latin1]{inputenc}
\usepackage{microtype}  % do not remove
\usepackage{pygmentize}
\usepackage{rgalg}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{xspace}

\usepackage[colorlinks]{hyperref} % keep it last to avoid some warnings

\RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}
\definecolor{darkred}{rgb}{0.4,0,0}
\definecolor{darkblue}{rgb}{0,0,0.4}
\definecolor{verylightgray}{rgb}{0.9,0.9,0.9}
\definecolor{lightblue}{rgb}{0,0,0.9}
% comment the next line for printing
\hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkblue}
\hypersetup{
  pdftitle={TOPL: A Language for Specifying Safety Temporal Properties of Object-Oriented Programs},
  pdfauthor={Radu Grigore and Rasmus Lerchedahl Petersen and Dino Distefano}}

\newcommand{\TPL}{TOPL}

\titlebanner{DRAFT}
\title{TOPL: A Language for Specifying Safety Temporal Properties of Object-Oriented Programs}
\authorinfo{Radu Grigore \and Rasmus Lerchedahl Petersen \and Dino Distefano}{Queen Mary, University of London}{{\rm\{}rgrig,rusmus,ddino{\rm\}}@eecs.qmul.ac.uk}

% rg: I tend to give grammars in BFS order
\def\grammar#1{{
  \footnotesize
  \def\b##1{{\rm\Verb@##1@}}\def\*{$^*$}\def\?{$^?$}\def\({$($}\def\){$)$}
  \def\|{$\mid$}\def\+{$^+$}
  \smallskip
  \hbox to\hsize{\hfil\vbox{\halign{\hfil\it##&$\;::=\;$\it##\hfil&\qquad\rm##\hfil\cr#1}}\hfil}
  \smallskip
}}

\renewcommand{\sectionautorefname}{Section}
\renewcommand{\subsectionautorefname}{\sectionautorefname}

\newcommand{\note}[2]{\textcolor{gray}{[\textcolor{red}{#1}: #2]}}
%\renewcommand{\note}[2]{}
\newcommand{\rg}[1]{\note{rg}{#1}}
\newcommand{\rlp}[1]{\note{rlp}{#1}}
\newcommand{\dd}[1]{\note{dd}{#1}}
\newcommand{\dinocomment}[1]{\dd{#1}}

\newcommand{\B}{\ensuremath{\mathbb{B}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\delimitVerbatim}{\par\nobreak\smallskip\noindent}
\newcommand{\error}{\ensuremath{\textcolor{darkred}{\mathtt{error}}}\xspace}
\newcommand{\eval}[1]{[[#1]]}
\newcommand{\pattern}[1]{\ensuremath{\mathtt{\underline{#1}}}}
\newcommand{\pmap}{\rightharpoonup}
\newcommand{\set}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\start}{\ensuremath{\mathtt{start}}\xspace}
\newcommand{\verbline}[2][]{\[\text{\Verb@#2@}#1\]}

\newcommand{\functionfont}[1]{\mathit{#1}}
\newcommand{\desugar}{\functionfont{des}}
\newcommand{\enabled}{\functionfont{enabled}}

\newcommand{\codefont}[1]{\mathtt{#1}}
\newcommand{\this}{\codefont{this}}

\theoremstyle{definition}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem{remark}{Remark}
\newtheorem{notation}{Notation}

\overfullrule=5pt
\showboxdepth=10
\showboxbreadth=30
% >>>
\begin{document}
\maketitle

% reviews summary <<<
% - why another language is needed
% - make clear that the implementation is for checking semantics
% - explain what techniques don't work for getting rid of roll-back
% - give an example of expressing 'null dereference is bad'
% - say early that our automata are non-deterministic
% - try to give one more example with two objects
% - explain why SOOL is introduced; include that events must be included in
%   the semantics of the programming language
% - explain early the convention with the implicit loop on start
% - picture for call-return: one arrow TOPL; semicolon iTOPL
% - S5: explain that lazy communication does NOT mean that you keep running
%   after the property is violated
% - pass thru running example
%   - use alpha, beta, ... for values
%   - say "c==alpha" rather than "holds"
% - other related work
%   - conspec
% - future work
%   - dynamic checking for Java with knob for soundness
%   - static checking
% >>>
\begin{abstract} % <<<
In this paper we present ongoing work related to a new specification language for temporal safety properties aimed at object-oriented software.
The language naturally captures relationships between objects and it is designed with the goal of performing dynamic and static analysis.
We present its formal semantics as well as several examples showing its expressivity.
\end{abstract}
\category{D.2.1}{Software Engineering}{Requirements/Specifications}
\terms Languages, Verification
\keywords Safety, Temporal Properties, Object-Oriented

% >>>
\section{Introduction} % <<<

The verification community showed interest in \emph{temporal safety properties} for a long time.
Manna and Pnueli~\cite{dblp:books/daglib/0080029} provide a theoretical foundation and clearly argue why such properties are crucial.
In this article, we focus on an object-oriented setting.
The long term aim of our project is the automatic verification of temporal safety properties for Java programs of realistic size.
To achieve our aim we need
\begin{itemize}
\item a language for formally specifying temporal safety properties, and
\item an automatic tool able to verify or check the properties expressed in the language against Java programs.
\end{itemize}
This paper addresses the first point by introducing \TPL\ (\textbf{t}emporal \textbf{o}bject-oriented \textbf{p}roperty \textbf{l}anguage, pronounced like `topple').

We draw inspiration from several existing specification languages, each of which we found not entirely suitable for our goal.
Bierhoff and Aldrich~\cite{dblp:conf/oopsla/bierhoffa07} as well as Naeem and Lhot\'ak~\cite{dblp:conf/oopsla/naeeml08} use specification languages inspired by typestates~\cite{strom1986}.
Specifically, Bierhoff and Aldrich~\cite{dblp:conf/oopsla/bierhoffa07} use a combination of linear logic~\cite{dblp:journals/tcs/girard87} and access permissions, while Naeem and Lhot\'ak~\cite{dblp:conf/oopsla/naeeml08} use tracematches.
Disney et al.~\cite{disney2011} use a language based on regular grammars to specify higher-order temporal contracts.
Finally, Ball and Rajamani~\cite{ball2002} essentially use nondeterministic aspect-oriented programming.

TOPL has the following characteristics:
\begin{enumerate}
\item It expresses easily relationships between several objects.
\item It is very high-level and similar to diagrams used in informal explanations.
\item It has a well-defined formal semantics in terms of a specific type of automatons.
\item It is designed to be used in program analysis (both static and dynamic).
\end{enumerate}
The ability to express relations of several objects makes \TPL\ quite expressive.
For example, for Java collections, a typical property one would want to state is:
\begin{quote}
If one iterator modifies its collection, then other existing iterators of the same collection become invalid and cannot be used later.
\end{quote}
\noindent
It is apparent that the formalization of the above constraint needs to keep track of several objects (at least two iterators, and one collection) and their interaction.
Most other techniques aim at decomposing properties involving several objects into specifications that reflect the point of view of a single object.
In contrast, TOPL does not try to achieve such decomposition.
Parkinson~\cite{parkinson-iwaco2007} argues that invariants involving several objects are sometimes better than one-object invariants.
Similarly, we believe that temporal properties that naturally involve several objects are easier to reason about if they are \emph{not} decomposed.

Because TOPL is a high-level language and has formal semantics (points 2~and~3 above), it reduces the semantic gap between the intuitive notion that programmers have of various temporal constraints on their code and the precise formal description needed by verification tools for automatic checking of these constraints.

In this paper we focus on TOPL's formal semantics and expressivity.
Moreover, we briefly discuss dynamic checking of TOPL properties.
The Java API, for example, has hand-crafted code for checking certain temporal properties (\autoref{sec:examples.steps}).
Such checks are
\begin{itemize}
\item hard to write,
\item weaved with the code that solves the actual problem, and
\item in the case of the Java API, do not provide a trace of the relevant events that lead to an error.
\end{itemize}
In contrast, dynamically checking TOPL properties avoids all these problems.

The paper is organized as follows. In Section~\ref{sec:examples} we start with few motivating examples.
Section~\ref{sec:syntax} gives the syntax of \TPL \ and in Section~\ref{sec:semantics} introduces its semantics.
Section~\ref{sec:related} discusses related work.
Finally, Section~\ref{sec:conclusions} concludes the paper and describes our plans for future work.

% >>>
\section{Examples} \label{sec:examples} % <<<

The first example (\autoref{sec:examples.steps}) uses a large part of \TPL\null.
Each execution step introduces a few new concepts.
The other examples (Sections~\ref*{sec:examples.iterators}--\ref*{sec:examples.ho}) illustrate TOPL expressiveness.

\rg{TODO: Property names are not consistent:
Should they read like an error message?
Should they say what is good or what is bad?}

\subsection{Iterators Step by Step} \label{sec:examples.steps} % <<<

The last statement in \autoref{fig:first.java} throws an exception.
There are two iterators on the same collection, one of them modifies the collection, and this invalidates the other iterator.
Such properties are often explained using diagrams~\cite{dblp:journals/scp/FieldGRY05,dblp:conf/issta/FinkYDRG06,dblp:conf/oopsla/bierhoffa07,dblp:conf/oopsla/naeeml08,dblp:conf/sigsoft/boddenlh08,dblp:conf/ecoop/bierhoffba09}.
The diagrams are sometimes precise, but not expressive enough~\cite{dblp:journals/scp/FieldGRY05,dblp:conf/issta/FinkYDRG06};
the diagrams are sometimes expressive, but not precise enough~\cite{dblp:conf/oopsla/bierhoffa07,dblp:conf/oopsla/naeeml08,dblp:conf/sigsoft/boddenlh08,dblp:conf/ecoop/bierhoffba09}.
\autoref{fig:first.diagram}, on the other hand, captures precisely a temporal property involving three interacting objects.
\autoref{fig:first.topl} describes the same property in (the textual form of) TOPL, and is clearly isomorphic to the diagram of~\autoref{fig:first.diagram}.
The rest of this section explains the semantics of \autoref{fig:first.diagram} and \autoref{fig:first.topl}:
\emph{Modifying a collection through an iterator invalidates other iterators for the same collection}.

Vertices have identifiers (\texttt{start}, \texttt{one}, \texttt{two}, \dots);
transitions have labels ($\pattern I:=\pattern C.\mathtt{iterator}()$, \dots).
There are two special vertices: \start, from where the execution begins; and \error, where the execution ends.
Labels capture, roughly, the shape of statements that enable the corresponding transition.

\begin{figure} % first example <<<
\include{IncorrectIteratorUse}
\caption{A first example: Java code}
\label{fig:first.java}
\end{figure}
\begin{figure}
\begin{Verbatim}
using prefix java.util.Collection
using prefix java.util.Iterator
\end{Verbatim}
\par\medskip
\begin{tikzpicture}
  \def\x{2.5}
  \tikzset{vertex/.style={draw,circle,inner sep=1pt}}
  \tikzset{transition/.style={->,>=latex}}
  \tikzset{every label/.style={gray}}
  \node[vertex] (start) at (0,0) [label=left:\texttt{start}] {};
  \node[vertex] (one) at (0,-1) [label=left:\texttt{one}] {};
  \node[vertex] (two) at (0,-2) [label=below:\texttt{two}] {};
  \node[vertex] (xBad) at (1*\x,-2.5) [label=right:\texttt{xBad}] {};
  \node[vertex] (yBad) at (-1*\x,-2.5) [label=left:\texttt{yBad}] {};
  \node[vertex,fill=darkred] (error) at (0,-3) [label=below:\textcolor{darkred}{\texttt{error}}] {};
  \draw[transition] (0,0.5)--(start);
  \draw[transition] (start)--node[right]{$\pattern X:=\pattern C.\mathtt{iterator}()$} (one);
  \draw[transition] (one) .. controls +(30:1cm) and +(-30:1cm) .. node[right]{$*$} (one);
  \draw[transition] (one)--node[right]{$\pattern Y:=\pattern c.\mathtt{iterator}()$} (two);
  \draw[transition] (two) -- node[sloped,above]{$\pattern y.\mathtt{remove}()$} (xBad);
  \draw[transition] (two)--node[sloped,above]{$\pattern x.\mathtt{remove}()$} (yBad);
  \draw[transition] (xBad)--node[sloped,below]{$\mathtt{call}\;\pattern x.{*}[*]$} (error);
  \draw[transition] (yBad)--node[sloped,below]{$\mathtt{call}\;\pattern y.{*}[*]$} (error);
\end{tikzpicture}
\caption{A first example: Diagram of safety property}
\label{fig:first.diagram}
\end{figure}
\begin{figure}
\begin{Verbatim}[commandchars=\\\{\}]
property InvalidateOtherIterators
  using prefix java.util.Collection
  using prefix java.util.Iterator
  start -> one:  \pattern{X} := \pattern{C}.iterator()
  one -> one:    *
  one -> two:    \pattern{Y} := \pattern{c}.iterator()
  two -> yBad:   \pattern{x}.remove()
  two -> xBad:   \pattern{y}.remove()
  yBad -> error: call \pattern{y}.*[*]
  xBad -> error: call \pattern{x}.*[*]
\end{Verbatim}
\caption{A first example: Safety property}
\label{fig:first.topl}
\end{figure}
\begin{figure}
{\def\s#1{\text{\Verb@#1@}}
 \def\m#1{\PY{n+na}{#1}}
 \def\t#1{\mathtt{#1}}
\begin{align*}
&\{\;(\start,[])\;\} \\
&\s{Iterator<Integer> i = c.\m{iterator}();} \\
&\text{assume {\tt c} holds $1$, and {\tt i} holds $2$ } \\
& \begin{aligned}
  \{\;&(\start,[]),\\
      &(\t{one},[c:1,x:2])\;\}
  \end{aligned}\\
&\s{Iterator<Integer> j = c.\m{iterator}();} \\
&\text{assume {\tt j} holds $3$} \\
& \begin{aligned}
  \{\;&(\start,[]),\\
      &(\t{one},[c:1,x:2]),\\
      &(\t{one},[c:1,x:3]),\\
      &(\t{two},[c:1,x:2,y:3])\;\}
  \end{aligned}\\
&\s{i.\m{next}();} \\
& \begin{aligned}
  \{\;&(\start,[]),\\
      &(\t{one},[c:1,x:2]),\\
      &(\t{one},[c:1,x:3]),\\
      &(\t{two},[c:1,x:2,y:3])\;\}
  \end{aligned}\\
&\s{i.\m{remove}();} \\
& \begin{aligned}
  \{\;&(\start,[]),\\
      &(\t{one},[c:1,x:2]),\\
      &(\t{one},[c:1,x:3]),\\
      &(\t{yBad},[c:1,x:2,y:3])\;\}
  \end{aligned}\\
&\s{j.\m{next}()} \\
& \begin{aligned}
  \{\;&(\start,[]),\\
      &(\t{one},[c:1,x:2]),\\
      &(\t{one},[c:1,x:3]),\\
      &(\error,[c:1,x:2,y:3])\;\}
  \end{aligned}\\
\end{align*}}
\caption{A first example: Running step by step}
\label{fig:first.steps}
\end{figure} % >>>

\autoref{fig:first.steps} shows an execution of the program and of an automaton for the property \texttt{InvalidateOtherIterators}.
The lines \{in curly brackets\} describe the state of the automaton;
the lines in \texttt{monotype} show the statements that execute;
the other lines are comments.
At a given moment, the automaton has a set of active states.
A state is a pair of a vertex and a store.
The store is a memory that holds (automaton) variables.
Technically, it is a finite partial map from variables to values.
(A partial finite map is sometimes called a \emph{dictionary}.)

\begin{notation}
We write $[k_1:v_1,k_2:v_2]$ for the finite partial map that maps key~$k_1$ to value~$v_1$, and key~$k_2$ to value~$v_2$.
The empty map is denoted by~$[]$.
\end{notation}

The automaton has variables $x$,~$y$, and~$c$.
At vertex \texttt{one} the variables $x$~and~$c$ are initialized;
at vertex \texttt{two} the variables $x$,~$y$, and~$c$ are initialized.
Being at vertex \texttt{one} means that $x$~is an iterator for~$c$;
being at vertex \texttt{two} means that $x$~and~$y$ are two iterators for the same collection~$c$.
There is a program variable~\Verb@c@ and an automaton variable~$c$.
The same name was chosen because the two variables always hold the same value in this example.
In general, however, program variables and automaton variables live in different name-spaces, and may hold different values.

\begin{notation}
Program variables are typeset in \Verb@monotype@ (\Verb@c@,~\Verb@i@,~\Verb@j@).
Automaton variables are typeset in \textit{italics} ($c$,~$x$,~$y$).
Program variables appear in the program;
automaton variables do \emph{not} appear in the property.
Instead, automaton variable \emph{patterns} appear in the property, and they are typeset in \texttt{\underline{underlined monotype}} (\pattern c,~\pattern C, \pattern x, \pattern X, \pattern y,~\pattern Y).
\end{notation}

\rg{Must define \emph{uppercase pattern} and \emph{lowercase pattern}.}
As it will become apparent below, the interaction between patterns and automatons' memory is as follows: uppercase patterns write to the automaton memory, and lowercase patterns read from the automaton memory and act as a guard on the transition.

\paragraph{Step~1.}

Initially, only the state $(\start,[])$ is active.
The outgoing transition of vertex \start is labeled by \[\pattern X:=\pattern{C}.\mathtt{iterator}()\] and the first executed statement is \verbline[.]{i = c.\PY{n+na}{iterator}()}
A method call matches a label when
\begin{itemize}
\item[(a)] the called method matches the method pattern, and
\item[(b)] the program values match their corresponding patterns.
\end{itemize}
By definition, any value matches an Uppercase pattern.
Here, the values of \Verb@i@~and~\Verb@c@ trivially match the patterns \pattern X~and~\pattern C.
The method itself also matches the method pattern, but for a slightly more complicated reason than it appears.
For simplicity, we ignore argument types and identify Java methods only by their fully qualified name and their arity.
The called method \texttt{iterator} is in the class \texttt{ArrayList} and has arity~$1$.
We identify it as follows.
\verbline{java.util.ArrayList.iterator[1]}
Without \texttt{using prefix} directives, the method pattern would be \Verb@iterator[1]@.
With the directives, however, the pattern is the following.
\begin{align*}
&\text{\Verb@java.util.Collection.iterator[1]@} \\
&\text{\Verb@java.util.Iterator.iterator[1]@}
\end{align*}
It means that these two methods \emph{and} all those that override them match.
Here, \texttt{ArrayList} implements \texttt{Collection}.

All conditions are met to enable the transition from \start to \texttt{one}.
When the transition is performed the values that matched \pattern X~and~\pattern C are written in the automaton variables $x$~and~$c$.
For concreteness, let us assume these values are $1$~and~$2$.
After the transition is performed, the state $(\mathtt{one},[c:1,x:2])$ is active.
The state $(\start,[])$ remains active because the implicit transition \verbline{start -> start: *} is also enabled and performed.
\rg{Say that this is a convention.}

\paragraph{Step~2.}
For the second step, the statement to be executed is \verbline[.]{j = c.\PY{n+na}{iterator}()}
Now we need to consider the two active states \[\{(\start,[])\quad\text{and}\quad(\texttt{one},[c:1,x:2])\}\] in turn.
For $(\start,[])$ the same reasoning as for step 1 holds, so the states $(\start,[])$ and $(\mathtt{one},[c:1,x:3])$ are active after step~2.
Note that now the automaton variable~$x$ remembers the value of the program variable~{\tt j}.
For $(\texttt{one},[c:1,x:2])$ we look at the transitions outgoing from vertex {\tt one}.
\begin{align*}
&\text{\Verb@one -> one: *@} \\
&\text{\Verb@one -> two: \pattern Y := \pattern c.iterator()@}
\end{align*}
The first of these transitions is always enabled, and performing it keeps states with vertex \texttt{one} active.
The second of these transitions has two patterns, \pattern Y~and~\pattern c.
The uppercase pattern~\pattern Y always matches;
the lowercase pattern \pattern c matches only the value held by the automaton variable~$c$.
In this case, the automaton variable~$c$ was set in the previous step to the value of the program variable~\texttt{c}.
Therefore, the transition from~\Verb@one@ to~\Verb@two@ is performed and the state $(\mathtt{two},[c:1,x:2,y:3])$ is activated.

\paragraph{Step~3.}

The third step involves the statement
\[\text{\Verb+\PY{n}{i}\PY{o}{.}\PY{n+na}{next}\PY{o}{(}\PY{o}{)}\PY{o}{;}+}\]
which enables the transitions
\begin{align*}
&\text{\Verb@one -> one: *@}\\
&\text{\Verb@start -> start: *@}.
\end{align*}
All the active states remain active, but for different reasons.
The active states with the vertex \start and those with the vertex \texttt{one} remain active because the enabled transitions are loops.
The active state with the vertex \texttt{two} remains active because no outgoing transition is enabled.
Therefore the set of active states of the automaton remains unchanged.

\paragraph{Step~4.}

In the fourth step, the transition $\texttt{two}\to\texttt{yBad}$ is performed.
Notice that the pattern $\pattern{x}.\mathtt{remove}()$ does not have a left-hand side, which simply means that the returned value is irrelevant for this transition.
The states corresponding to vertices \start and {\tt one} remain unchanged, because their outgoing transitions are disabled.
However,  the outgoing transition of state {\tt two} is enabled, and therefore {\tt yBad} becomes active.

\paragraph{Step~5.}

For the fifth and final step, the statement to be executed is \verbline[.]{j.\PY{n+na}{next}()}
The label of the outgoing transition  \[\mathtt{call}\;\pattern{y}.{*}[*]\] of the active state $(\texttt{yBad},[c:1,x:2,y:3]),$
has two distinguishing features: the~$*$ as a method name and the tag \texttt{call}.
As before, in order to match the method name, the following prefixes are prepended  
\begin{align*}
&\text{\Verb@java.util.Collection.*[*]@} \\
&\text{\Verb@java.util.Iterator.*[*]@}
\end{align*}
Then the $*$s are expanded, taking into account the \texttt{CLASSPATH}.
We have a match because the expansion \verbline{java.util.Iterator.next} is overridden by the method that is actually called.

The tag {\tt call} is used when we want the automaton to take a transition precisely at call-time of a method invocation.
The automaton expresses that a call to one of {\tt j}'s methods while vertex \texttt{yBad} is active constitutes an error.
Notice that this is different from a label like $\pattern X:=\pattern C.\mathtt{iterator}()$ which may match only after the return value is known.

\medskip
The execution we stepped through reaches the \error vertex, so we conclude that the property is violated.
Notice that in order to find a counterexample we need to keep track of the relation between several objects, in particular that iterators {\tt i} and {\tt j} are for the same collection {\tt c}.

\rg{Add a summary that explains why this is easy to write, not weaved with the code, and can provide traces.}

% >>>
\subsection{More on Iterators} \label{sec:examples.iterators} % <<<

Other interesting properties of iterators~\cite{dblp:conf/oopsla/naeeml08,dblp:conf/sigsoft/boddenlh08,haack2009} are also easy to express in TOPL\null.

\medskip\emph{Modifying a collection invalidates all its existent iterators:}
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
property ModificationInvalidatesIterators
  using prefix java.util.Collection
  using prefix java.util.Iterator
  start -> iterating:    \pattern{I} := \pattern{C}.iterator()
  iterating -> modified: \pattern{c}.add(*), \pattern{c}.remove(*)
  modified -> error:     call \pattern{i}.*[*]
\end{Verbatim}
\delimitVerbatim
This property should list all the methods of \textit{Collection} that mutate it.
If classes that implement \textit{Collection} add mutating methods, then those should be included as well.
This abstraction leak is intrinsic to Java where sub-classing is not sub-typing.

\medskip\emph{Iterators should advance only if they are not exhausted:}
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
property UnsafeIteratorNext
  using prefix java.util.Collection
  using prefix java.util.Iterator
  start -> iterating:        \pattern{I} := *.iterator()
  iterating -> notExhausted: \pattern{true} := \pattern{i}.hasNext()
  notExhausted -> iterating: \pattern{i}.next()
  iterating -> error:        \pattern{i}.next()
\end{Verbatim}
\delimitVerbatim
The transition from \Verb@iterating@ to \Verb@notExhausted@ is enabled when \Verb@hasNext@ returns \Verb@true@.
In general, Java literals act as guards on transitions.

\medskip\emph{Method \Verb@remove@ may only be called after \Verb@next@:}
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
property RemoveBeforeNext
  using prefix java.util.Collection
  using prefix java.util.Iterator
  start -> created: \pattern{I} := *.iterator()
  created -> ok:    \pattern{i}.next()
  created -> error: \pattern{i}.remove()
\end{Verbatim}
\delimitVerbatim
TOPL is designed to track properties involving multiple objects.
However, properties involving a single object are also easy to express.
The vertex \Verb@ok@ is not special.
The purpose of the transition going to \Verb@ok@ is to deactivate the state with vertex \Verb@created@.

\medskip
We have now seen four properties of iterators.
Each of the previous TOPL properties corresponds to one English sentence.

% >>>
\subsection{Resources} % <<<

Many resources impose two temporal properties:
Before being used they must be acquired;
after being acquired they must eventually be released.
Resources include memory, files, sockets, locks.
Memory must be allocated before reading or writing and should eventually be deallocated;
files must be opened before reading or writing and should eventually be closed;
sockets must be created before sending and receiving data and should eventually be closed;
locks should be acquired before accessing the memory they protect and should eventually be released.
Resources are usually represented by objects.
\delimitVerbatim
\input{Resource}
\delimitVerbatim
To create a resource, we use the static method \Verb@makeResource@.

\medskip\emph{A resource must be acquired when used:}
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
property ResourceSafety
  start -> released:    \pattern{R} := makeResource()
  released -> error:    \pattern{r}.use()
  released -> acquired: \pattern{r}.acquire()
  acquired -> released: \pattern{r}.release()
\end{Verbatim}
\delimitVerbatim
In simple cases, resources cannot repeatedly move between the states \Verb@released@ and \Verb@acquired@.
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
property ResourceSafetySimple
  start -> acquired:    \pattern{R} := makeResource()
  acquired -> released: \pattern{r}.release()
  released -> error:    \pattern{r}.use()
\end{Verbatim}
\delimitVerbatim
The following examples in this subsection only cover the case when \Verb@acquire@ must be called explicitly.

\medskip\emph{A resource must not be released twice:}
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
property DoubleRelease
  start -> released:    \pattern{R} := makeResource()
  released -> acquired: \pattern{r}.acquire()
  acquired -> released: \pattern{r}.release()
  released -> error:    \pattern{r}.release()
\end{Verbatim}
\delimitVerbatim
Similarly, one can express that a resource must not be acquired twice.

\medskip\emph{A resource must eventually be released:}
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
property ResourceLeak
  start -> released:    \pattern{R} := makeResource()
  released -> acquired: \pattern{r}.acquire()
  acquired -> released: \pattern{r}.release()
  acquired -> error:    return Main.main[1]
\end{Verbatim}
\delimitVerbatim
TOPL is designed for safety properties, which have finite counter-examples.
It is not possible to express the lack of resource leaks in non-terminating programs.
It is possible, however, to check if resources are leaked when the program terminates.

% >>>
\subsection{\textsc{Slic} Queue} % <<<

\textsc{Slic}~\cite{ball2002} is the property language of SLAM~\cite{dblp:conf/cav/ballr01}.
Its authors give the following interesting example.

\medskip\emph{A queue may contain at most three zeros:}
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
property TooManyZeros
  start -> cnt0: \pattern{Q} := makeQueue()
  cnt0 -> cnt1:  \pattern{q}.put(0)
  cnt1 -> cnt2:  \pattern{q}.put(0)
  cnt2 -> cnt3:  \pattern{q}.put(0)
  cnt3 -> error: \pattern{q}.put(0)
  cnt3 -> cnt2:  0 := \pattern{q}.get()
  cnt2 -> cnt1:  0 := \pattern{q}.get()
  cnt1 -> cnt0:  0 := \pattern{q}.get()
\end{Verbatim}
\delimitVerbatim
The vertex \texttt{cnt}\textit{x} means that there are $x$~zeros in~$q$.
A natural generalization is to allow at most $n$~zeros.
The size of the TOPL property text grows linearly with~$n$.
A better solution would be to allow incrementing and decrementing of automaton variables when transitions are performed.
This feature can be easily added to TOPL\null.
However, this is the only example we have encountered so far that would require incrementing and decrementing automaton variables.
For this reason, we chose to keep \TPL \ simple and not include this feature.

% >>>
\subsection{Recursivity and Atomicity}\label{sec:examples.ho} % <<<

This section is inspired by the higher-order temporal properties of Disney et al.~\cite{disney2011}.

\medskip\emph{The \Verb@sort@ method is not recursive:}
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
property RecursiveSort
  using prefix Sorter
  start -> inSort: call sort[*]
  inSort -> ok:    return sort[*]
  inSort -> error: call sort[*]
\end{Verbatim}

\medskip\emph{Method~\Verb@m@ should be atomic:}
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
property NotAtomicM
  start -> inM: call m[*]
  inM -> ok:    return m[*]
  inM -> error: call badCall[*]
\end{Verbatim}
\delimitVerbatim
All the events that should not intervene between the call to~\Verb@m@ and the return from~\Verb@m@ must be explicitly mentioned.
Otherwise, if the granularity for atomicity is implicit, then it is easy for users to make mistakes.

% >>>
% >>>
\section{Syntax}\label{sec:syntax} % <<<

We begin the systematic presentation of TOPL with its syntax (\autoref{sec:syntax.topl}).
Before moving on to semantics (\autoref{sec:semantics}) we shall also introduce the syntax of SOOL, a \textbf simple \textbf object-\textbf oriented programming \textbf language (\autoref{sec:syntax.sool}).

\subsection{TOPL and iTOPL}\label{sec:syntax.topl} % <<<

% plan
% - two languages
% - language for users
% - language for semantics
% - desugaring translation

TOPL aims to be intuitive:
Labels look like method calls, there is a shorthand notation for parallel transitions, there is an implied loop on the vertex \start, the \texttt{using prefix} directive offers some extra convenience, and so on.
From the point of view of semantics, however, these conveniences are in the way.
For this reason we also define iTOPL (\textbf inner TOPL), an even simpler language into which TOPL is desugared.

\autoref{fig:syntax.topl} shows the syntax of TOPL\null.
A property has a name, a set of \texttt{using} directives, and a set of transitions.
Each transition has an arc (directed edge) and labels.
Each arc has a source vertex and a target vertex.
All vertices are identified by their name.
Labels look roughly like method calls.
Each label has a method pattern that is used to identify the set of methods to which the label refers.
In the simple case, a method pattern consists of a string pattern for the name of the method and an integer that specifies the method arity.
(For simplicity, TOPL does not use the static types of arguments to distinguish between overloaded methods.)
The more interesting case is when there are value patterns for each argument and perhaps even for the result.
Transitions should typically be tagged with \texttt{call} or \texttt{return} to specify exactly at what time they should be performed (see \autoref{sec:semantics.itopl} for details).

\begin{figure}
\grammar{
  Property& \b{property} Identifier Using\* Transition\* \cr
  Using& \b{using prefix} StringPattern \cr
  Transition& Arc \b: Label \(\b, Label\)\* \cr
  StringPattern& \(Letter \| \b. \| \b*\)\+ \cr
  Arc& Vertex \b{->} Vertex \cr
  Label& Tag\? MethodPattern \cr
  Vertex& Identifier \cr
  Tag& \b{call} \| \b{return} \cr
  MethodPattern& ResultPattern\? NamePattern ArgumentsPattern \cr
  ResultPattern& ValuePattern \b{:=} \cr
  NamePattern& StringPattern \cr
  ArgumentsPattern& \b( \(ValuePattern \(\b, ValuePattern\)\*\)\? \b) \cr
  ArgumentsPattern& \b[ IntegerPattern \b] \cr
  ValuePattern& \b* \| Literal \| UppercaseId \| \b!\? LowercaseId \cr
  IntegerPattern& \b* \| IntegerLiteral \cr
}
\caption{Syntax of TOPL}
\label{fig:syntax.topl}
\end{figure}

There are three types of patterns used in TOPL---for strings, for integers, and for values.
String patterns are POSIX globs~\cite{man:glob.h} and match method names.
(For simplicity, TOPL does not use full regular expressions as string patterns.)
Integer patterns specify method arities.
Value patterns are the most interesting.
For each automaton variable \Verb@var@ there are three associated patterns.
The uppercase pattern \Verb@Var@ matches any value and writes it in the automaton variable \Verb@var@.
The lowercase pattern \Verb@var@ reads the value of the automaton variable \Verb@var@ and only matches that value.
The negated lowercase pattern \Verb@!var@ reads the value of the automaton variable \Verb@var@ and only matches different values.
A Java literal acts as a pattern that matches only the value it denotes.
A wildcard~* pattern matches any value.

A TOPL property is \emph{well-formed} when it satisfies the following conditions.
\begin{itemize}
\item A transition may prescribe at most one write to an automaton variable.
In other words, an uppercase value pattern may appear at most once within a label.
\item Automaton variables must be written before being read.
In other words, lowercase value patterns must be preceded by corresponding uppercase value patterns on all paths comming from \start.
\end{itemize}
It is easy to check that a property is well-formed~\cite{web:topl.prototype}.
From now on we assume TOPL properties to be well-formed.
\autoref{fig:syntax.itopl} shows the syntax of iTOPL\null.
The missing productions (such as \textit{Arc}) are the same as for TOPL\null.
Each transition now has exactly one label.
Each label is a list of (guard, action) pairs.
Each guard is some boolean combination of atomic guards.
Each action is a sequence of atomic actions.
Both guards and actions refer to some implicit array of values using an index (see \autoref{sec:semantics.itopl}).
Atomic guards compare values either with automaton variables (\textit{Identifier}) or with constants (\textit{Literal}).
Atomic actions write values into automaton variables.
There is also an atomic guard that matches against method calls and always specifies a tag \Verb@call@ or \Verb@return@, but never involves examining any values.

\begin{figure}
\grammar{
  Property& \b{property} Identifier Transition\* \cr
  Transition& Arc \b: Label \cr
  Label& \(\b(Guard Action\b)\)\* \cr
  Guard& AtomicGuard \| Guard \(\(\b{\&}\|\b|\) Guard\)\* \cr
  Action& \(AtomicAction \(\b, AtomicAction\)\*\)\? \cr
  AtomicGuard& \b! Guard \cr
  AtomicGuard& \b[ ValueIndex \b] \b= \(Identifier \| Literal\)\cr
  AtomicGuard& \(\b{call} \| \b{return}\) NamePattern \b[ IntegerPattern \b] \cr
  AtomicGuard& \b{true} \cr
  AtomicAction& Identifier \b{:=} \b[ ValueIndex \b] \cr
  ValueIndex& IntegerLiteral \cr
}
\caption{Syntax of iTOPL}
\label{fig:syntax.itopl}
\end{figure}

% >>>
\subsection{Translating TOPL into iTOPL}\label{sec:syntax.desugaring} % <<<
TOPL is designed to express properties over traces of events
pertaining to method calls.
A method call $u.m(v_1, \ldots, v_n)$ that returns $w$ will generate the following two events:
\[
\begin{array}{l}
  \mathtt{call}_{m[n+1]}\ [u, v_1, \ldots, v_n] \qquad \mathrm{and} \\
  \mathtt{return}_{m[n+1]}\ [w]
\end{array}
\]
The call events are matched by labels of the form
\[
  \mathtt{call}\ p_0.m(p_1, \ldots, p_n)
\]
with $n$ value patterns for the arguments,
while the return events are matched by labels of the form
\[
  \mathtt{return}\ p_0:=m
\]
with one value pattern for the return value.
In both cases the TOPL labels give rise to an iTOPL label with one
(guard, action) pair.

The guard is constructed by stating that all automaton variables
should have the appropriate values. That is, all lowercase automaton
patterns $\pattern{x} = p_i$ amongst the value
patterns give rise to a guard term of the form
\[
event[i] = x
\]
(or $event[i] \neq x$ in the case of $p_i = {!\pattern{x}}$), referring to the
array of values carried by the event.
The guard is then the conjunction of all these guard terms.

The action expresses that automaton variables should be updated. So
all uppercase automaton variables $\pattern{X} = p_i$ amongst the value
patterns give rise to an update term of the form
\[
x := event[i]
\]
The action is then the concatenation of all such update terms.

But it is also possible to write labels of a third form in TOPL,
namely
\[
p'_0 := p_0.m(p_1, \ldots, p_n)
\]
Such a label expresses both a call of the method $m$ with the
arguments matching $p_0, \ldots, p_n$ and a return with the value
matching~$p'_0$.
In this case, the iTOPL label is a list of two (guard, action) pairs.
The first element corresponds to the label $\mathtt{call}\
p_0.m(p_1, \ldots, p_n)$ and the second corresponds to the label $\mathtt{return}\ p'_0:=m$.

% >>>
\subsection{SOOL}\label{sec:syntax.sool} % <<<

Traces of events act as a thin interface between programs and iTOPL properties.
To use iTOPL with some programming language, one must define how programs in that language produce events.
Also, because iTOPL is low-level, one should design a high-level property language.
TOPL is an example of a high-level property language built on top of iTOPL that is suitable in an object-oriented setting.
SOOL is an example of an object-oriented programming language that produces events.

The following is a small snippet of a SOOL program.
\delimitVerbatim
\begin{Verbatim}
class User
  Unit remove(Collection c, Object x)
    var Bool hasNext
    var Iterator i := c.iterator()
    do { hasNext := i.hasNext() }
    while hasNext
      var Object y := i.next()
      if x == y { i.remove() }
    return unit
\end{Verbatim}
\delimitVerbatim
In SOOL, statements are grouped by $\{$curly brackets$\}$ or by indentation.
SOOL expressions do not have side-effects.
Method calls have side-effects---they are statements.
There is only one type of loop, which checks its condition at some arbitrary point (like \Verb@\loop@ in~\TeX).
Other aspects of SOOL are fairly standard.

\autoref{fig:syntax.sool} shows a big part of SOOL's syntax.

\begin{figure}
\grammar{
  Program& Class\* Main\cr
  Class& \b{class} Identifier Member\* \cr
  Main& \b{main} Body \cr
  Member& Type Identifier & data \cr
  Member& Type Identifier \b( Formals\? \b) Body & code\cr
  Body& Statement\* \cr
  Formals& Type Identifier \(\b, Type Identifier\)\* \cr
  Statement& \b{return} Expression & return\cr
  Statement& Reference \b{:=} \b{new} & allocate \cr
  Statement& Reference \b{:=} \b* & read \cr
  Statement& Reference \b{:=} Reference \b( Actuals\? \b) & call \cr
  Statement& \b{do} Body \b{while} Expression Body &loop\cr
  Statement& \b{if} Expression Body \b{else} Body &test\cr
  Reference& Expression \b. Identifier \cr
  Actuals& Expression \(\b, Expression\)\* \cr
}
\caption{(Partial) Syntax of SOOL}
\label{fig:syntax.sool}
\end{figure}

% >>>
% >>>
\section{Semantics}\label{sec:semantics} % <<<

A program's semantics is a set of event traces;
an automaton's semantics is also a set of event traces.
We say that a program \emph{violates} a property when their sets of traces intersect.
In other words, properties encode bad executions, rather than good executions.

\begin{notation}
Sets are typeset in \set{SansSerif} with two exceptions---$\B$~is the set $\{0,1\}$, and $\N$~is the set $\{0,1,2,\ldots\,\}$.
We write $\set A\times\set B$ for the set of all pairs $(a,b)$ with $a\in\set A$ and $b\in\set B$.
We write $\set A\to\set B$ for the set of functions from~\set A to \set B.
In particular, the powerset of~\set A is isomorphic to~$\set A\to\B$.
Note that $(\set A\to\set B)\subset\bigl((\set A\times\set B)\to\B\bigr)$.
For all $f\in\set A\to\set B$, we write $f\;a$ or $f(a)$ to denote the unique~$b$ such that $(a,b)\in f$.
We write $\set A\pmap\set B$ for the set of finite partial maps from~\set A to~\set B.
Again, $(\set A\pmap\set B)\subset\bigl((\set A\times\set B)\to\B\bigr)$.
However, there are functions that are not finite partial maps, and there are finite partial maps that are not functions.
For all $f\in\set A\pmap\set B$, the domain $\{a\mid\text{$(a,b)\in f$ for some $b$}\}$ is finite.
We write $f\;a$ or $f(a)$ only when $a$ is in the domain of~$f$.
We write $\set A\,\mathsf{array}$ for $\bigcup_{n\in\N}
\bigl(\{0,1,\ldots,n-1\}\to\set A\bigr)$.
For $i\in\N$ and $a\in\set A\,\mathsf{array}$, we will usually write $a_i$
instead of $a\;i$.
\end{notation}

\subsection{Semantics of iTOPL}\label{sec:semantics.itopl} % <<<
Each property gives rise to an automaton defined over the labeled multigraph $(\set{Vertex}, \set{Arc})$ given by the transitions:
$\set{Vertex}$ is the set of vertices mentioned as endpoints of the arcs and $\set{Arc}$ is the set of labeled arcs mentioned in transitions.

The automaton takes as input a trace of events.
Each event~$e$ contains an array of values.
Within guards and actions we write $e[i]$ for the $i$th value associated to event~$e$ (0-based).
For values, we assume a countable set \set{Value} and for events we assume
a finite set \set{Event} of events with known arity.
\rg{Does the cardinality of \set{Value} matter?}
\rg{Does the cardinality of \set{Event} matter?}

We will now describe how the automaton reacts to events, specifically
how labels are evaluated. As this is a slightly non-standard
automaton, there are some important things to point out. Firstly, the
state of the automaton is not just a vertex but also a store. 

That is, there is a set $\set{Variable}$ of automaton variables, and the state of the automaton is
given by specifying the vertex in the graph as well as the value of
all automaton variables.

We model stores as finite partial maps with finite domain.
\[
\set{Store} = \set{Variable} \pmap \set{Value}
\]
And so a state of the automaton has the type
\[
\set{State} = \set{Vertex}\times\set{Store}
\]
Given the state of the automaton and an event we would like to know
which transitions are enabled. But actually, we do not have enough
information to determine that. This is a consequence of the second
slightly non-standard aspect of our automatons, namely that each label
carries not only a single guard but potentially a list of guards.
We call the length of this list, the \emph{depth} of the transition.

In order for a transition to be enabled, all the guards along its
list have to evaluate to true. We will describe this evaluation in a
moment, but now we note that each guard along the transition consumes
an event.
Thus, if a transition has depth~$n$, then we have to examine the next~$n$ events to see if the transition is enabled.

A further consequence is that the following events to be received are
not the same at the end of each enabled transition. If two transitions
turn out to be enabled, one with depth 2 and the other with depth 5,
then the end state of the first transition will see the third event of
the trace next, while the end state of the second transition will see
the sixth event next. For this reason, it is necessary to keep track
of which events are next to be received by each state during a run of
the automaton.

To formalize this bookkeeping, we introduce the notion of
\emph{execution state}. For brevity, we call execution states worlds.
\[
\set{World} = \set{State}\times\set{Trace}
\]
The first component records the state of the automaton (vertex
and store) and the second component records the remaining trace of
events for that state.

We now describe when transitions are enabled. For this we have to look
at labels. A label is a list of pairs of guards and actions. A
guard compares the values in an event with those in a store and
concludes either pass or no pass:
\[
\set{Guard} = \set{Event}\times\set{Store}\to\B
\]
if the event passes, the corresponding action is performed on that event.
Actions modify the store, using values from an event:
\[
\set{Action} = \set{Event}\times\set{Store}\to\set{Store}
\]
In order for a transition of depth $n$ to be enabled for a trace of
events, the first $n$~events of the trace must pass the $n$~guards
on the label with the stores modified by the guards:
\[
\begin{array}{c l}
& \enabled((g_1, a_1), \ldots, (g_n, a_n); e_1, \ldots, e_n; s) \\
 = &
g_1(e_1, s_0)\ \land\ \ldots\ \land\ g_n(e_n, s_{n-1}) 
\end{array}
\]
where
\begin{align}
  s_0 &=  s \\
  s_i &= a_i(e_i, s_{i-1}) &&\text{for $i\in1.\,.\,n$}
\end{align}
If the transition is enabled and performed, the store for the target vertex will be $s_n$.

And now we reach the final slightly non-standard aspect of our
automatons, namely that if no transitions are enabled for a given
state and trace of events, the automaton does not get stuck but is
allowed to consume one event without changing its state. Note that
this is not equivalent to an implied self-loop on all states, as
dropping events is not allowed if there are any enabled
transitions. In that case one of the enabled transitions is performed and
the automaton execution state becomes $((v, s_n), \mathit{events}_n)$, where $v$ is the vertex at the
end of the arc of the transition, $s_n$ is defined as above and
$\mathit{events}_n$ is the current executions state's event trace with the first
$n$ events dropped.
\rg{An example would help to understand this paragraph.}

We can define a predicate that determines the possible execution state transitions
\[
\mathit{Step}\in\set{World}\to\set{World}\to\B
\]
this predicate is defined in \autoref{fig:adStep}.
From this we can define a non-deterministic step function, where all
enabled transitions are performed:
\begin{align}
\mathit{NdetStep}&\in(\set{World}\to\B)\to(\set{World}\to\B)\\
%\mathit{NdetStep}\;S&=(\bigcup \mathit{Step})\;S \label{eq:ndetstep}
\mathit{NdetStep}\;S&=\{ s \mid \text{$\mathit{Step}(s', s)$ for some $s'\in S$} \} \label{eq:ndetstep}
\end{align}
An iterated version of \textit{NdetStep} is useful for defining reachable states.
We define it as the least fixed point for the following equation.
\begin{align}
\mathit{NdetStep}^\star\;S &= S \cup \mathit{NdetStep}^\star\;(\mathit{NdetStep}\;S)
\end{align}
\rlp{Should this really include 0-sized steps?}
\rg{I prefer to keep epsilon transition, unless there is a good reason to special-case them.}
Finally, we can define the set of traces described by an automaton:
\[
\{ e \mid
\exists\sigma'e',\;((\mathtt{error},\sigma'),e')\in\mathit{NdetStep}^\star\;\{((\mathtt{start},[]),e)\}
\}
\]
These are the traces that drive the automaton from the \texttt{start} vertex (with an empty store) to the \texttt{error} vertex.
\begin{figure}
\hbox to\hsize{\vbox{
\begin{alg}
\^  $\proc{Step}\;((x_1,\sigma_1),e_1)\;((x_2,\sigma_2),e_2)$
\=  ~if~ $e_2$ is not a suffix of $e_1$ ~then return~ $0$
\=  $e:=\text{$e_1$ without the suffix $e_2$}$
\=  ~for each~ transition $((y_1,y_2),l)$
\+    ~if~ $(y_1,y_2)\ne(x_1,x_2) \lor \mathit{len}\;l\ne\mathit{len}\;e$ ~then continue~
\=    $\sigma:=\sigma_1$
\=    ~for each~ $k\in 1\ldots\mathit{len}\;l$
\+      $(g,a):=l[k]$
\=      ~if~ $\lnot g(e_k,\;\sigma)$ ~then continue~ to line 3
\=      $\sigma:=a(e_k,\;\sigma)$
\-    ~if~ $\sigma=\sigma_2$ ~then return~ $1$
\-  ~return~ $\mathit{len}\;e=1\land\sigma_1=\sigma_2$
\end{alg}
\smallskip
}\hfil}
\caption{One automaton step}
\label{fig:adStep}
\end{figure}
% >>>
\subsection{Semantics of SOOL} \label{sec:semantics.sool} % <<<

The \emph{program state} holds method parameters and dynamically allocated objects.
Method parameters are held in a store;
dynamically allocated objects are held in the heap.
The \emph{heap} is a finite partial map from (object reference, field name) pairs to values.
\begin{align}
\set{SoolState}&=\set{Store}\times\set{Heap}\\
\set{Store}&=\set{Variable}\pmap\set{Value} \\
\set{Heap}&=(\set{Value}\times\set{Variable})\pmap\set{Value}
\end{align}
The input is a stream of values;
the output is an array of events.
The \emph{program world} keeps track of the program state, the input yet to be consumed, and of the output already produced.
\begin{align}
\set{Input}&=\N\to\set{Value} \label{eq:input}\\
\set{Trace}&=\set{Event}\,\mathsf{array} \\
\set{SoolWorld}&=\set{SoolState}\times\set{Input}\times\set{Trace} \\
((\sigma, h), i, o)&\in\set{SoolWorld} \label{eq:epstate.element}
\end{align}
Equation~\eqref{eq:epstate.element} shows the general form of an element of~\set{SoolWorld}: $\sigma$~is the store that holds parameters, $h$~is the heap that holds dynamically allocated objects, $i$~is the input stream yet to be processed, and $o$~is the array of events already emitted.
The implementation~\cite{web:topl.prototype} also has local variables, which are treated similarly to method parameters.

Executing a SOOL program amounts to executing the \Verb@main@ body, which is a compound statement.
\begin{align}
\mathit{exec}&\in(\set{SoolWorld}\times\set{Statement})\to(\set{SoolWorld}\times\set{Value})
\end{align}
Method calls are interesting.
The general form of a method call is \[ e.x := f.m(g_1,\ldots,g_n)\] where $e$,~$f$, $g_1$, \dots, $g_n$ are expressions, $x$~identifies a data field, and $m$~identifies a method.
Expressions evaluate to values and do not have side-effects.
\begin{align}
\set{Expression}&=\set{SoolState}\to\set{Value} \\
e,f,g_1,\ldots,g_n&\in\set{Expression}
\end{align}

\begin{notation}
The map $\sigma[k:v]$ is the same as the map~$\sigma$, except it maps $k$~to~$v$.
\end{notation}

\autoref{fig:exec.call} shows the definition of \textit{exec} for method calls.
In spite of the imperative-looking notation, there is no mutation:
Different versions of $\sigma$,~$h$, $i$, and~$o$ get different indices.
Line~1 introduces a shorthand notation for the program state~$s$.
Line~2 looks up in the program text a method named~$m$.
We assume that method names are unique.
The formal parameters of~$m$ are $x_1$,~\dots,~$x_n$.
We assume a type-checker enforces that all calls are made with the correct number of arguments.
The body of~$m$ is~$b$.
Line~3 constructs a store that maps formal arguments to the actual values;
$\sigma_1$~is commonly called the \emph{call stack frame} of~$m$.
Line~4 emits the first event:
It has tag $\mathtt{call}m$ and carries the actual argument values.
Line~5 executes the body, by calling \textit{exec} recursively.
Line~6 emits the second event:
It has tag $\mathtt{return}m$ and carries the return value.
Line~7 stores the return value in the heap.
Finally, line~8 returns the updated program execution state and the unit value~$()$.

\begin{figure}
\hbox to\hsize{\vbox{
\begin{alg}
\^  $\proc{exec}\Bigl(\bigl((\sigma_0,h_0),i_0,o_0\bigr),\bigl(e.x:=f.m(g_1,\ldots,g_n)\bigr)\Bigr)$
\=  $s:=(\sigma,h)$
\=  $((x_1,\ldots,x_n), b) :=\mathit{methodOfName}\;m$
\=  $\sigma_1:=[\textbf{this}:(f\;s), x_1:(g_1\;s), \ldots, x_n:(g_n\;s)]$
\=  $o_1:=\text{$o_0$ with $(\mathtt{call}m,[f\;s,g_1\;s,\ldots,g_n\;s])$ appended}$
\=  $(((\sigma_2,h_2),i_2,o_2),v):=\mathit{exec}\bigl(((\sigma_1,h_0),i_0,o_1),b\bigr)$
\=  $o_3:=\text{$o_2$ with $(\mathtt{return}m,[v])$ appended}$
\=  $h_3:=h_2[(e\;s, x) : v]$
\=  ~return~ $(((\sigma_2,h_3),i_2,o_3), ())$
\end{alg}
\smallskip
}\hfil}
\caption{Executing one SOOL method call}
\label{fig:exec.call}
\end{figure}

Other statements are interpreted as usual and are not interesting.

Given a program with the main body~$b$, the output trace~$o$ corresponding to some input~$i$ is obtained by starting the execution with an empty store~$[]$, an empty heap~$[]$, and an empty output~$[]$.
\begin{align}
((\_,\_,o),\_):=\mathit{exec}\bigl((([],[]),i,[]),b\bigr)
\end{align}

% >>>
\subsection{Implementation}\label{sec:implementation} % <<<

In order to test the semantics, we implemented a TOPL and SOOL interpreter~\cite{web:topl.prototype}.
Indeed, the implementation helped us understand TOPL\null.
There are two main differences with the presentation above.

First, we under-approximate nondeterminism by randomness.
Where the semantics prescribe a set~$S$ of active states, the interpreter tracks only one active state~$s\in S$.
A random number generator guides the choice of~$s$ at each step.
Thus, different seeds of the random number generator explore different traces.
Simulating nondeterminism by randomness is unsound.
However, the TOPL and SOOL interpreter is not meant to prescribe how dynamic analysis of TOPL properties should be done.

Second, the trace of events is communicated from the SOOL interpreter to the TOPL interpreter lazily.
The only consequence is that less memory is used.
At most two events are remembered at any one time, rather than the whole trace.

If the reader finds any part of \autoref{sec:semantics} ambiguous or incomplete, then the code should clarify the details.

% >>>
% >>>
\section{Related Work}\label{sec:related} %<<<
Our work is based on the concept of typestate~\cite{strom1986} originally developed for imperative programs and extends this fundamental concept by integrating notions typical of object-oriented programs. 
We are certainly not the first in doing this: there are several extensions of typestate to object-oriented programming in the literature.
A modular static verification method for typestate protocols is introduced in~\cite{dblp:conf/oopsla/bierhoffa07}. 
The specification method is based on linear logic and relations among objects in the protocol are monitored by a tailored system of permissions. 
The method is highly modular and presumably efficient. The specification of the interactions among objects by means of permissions adds an extra level of machinery which increases the gap between the intuitive protocol description and its formalization. Similarly~\cite{deline2004,dblp:conf/sigsoft/BierhoffA05} provide a mean to specify typestate properties that belong to a single object. The specified properties are reminiscent of contracts or pre/post-conditions for methods and
can deal with inheritance.
In~\cite{dblp:conf/issta/FinkYDRG06} the authors present sound verification techniques for typestate properties of Java  programs.
Their approach is divided in several stages with different verifiers varying for cost and precision.
In the early stages efficient but imprecise analyses are employed whereas
more expensive and precise techniques are then progressively employed in later stages.
Every stage focuses on verifying only the parts of the code that previous stages failed to verify.
This work focuses on analysis whereas we focus on presenting a useful specification language as the base for verification.
It is likely that our language could be fruitfully combined with their analysis technique.

An automaton-based formalism for specifying properties of software interfaces were introduced in~\cite{dblp:conf/sigsoft/AlfaroH01} . 
This language aims at capturing assumptions about the order in which the methods of a component are called and the order in which the component calls external method.
In contrast to \TPL, this formalism is mainly used to check the compatibility of the interfaces of two components and it is designed to be applied at  model level rather than code level. A specification language for interface checking aimed to C programs (called SLIC) is introduced in~\cite{ball2002}.  
Differences between SLIC and \TPL \ include: the use (in SLIC) of
non-determinism to encode universal quantification of dynamically allocated data, and the  ability to have complex code in the automaton transitions. 
\TPL \ specifications naturally express universally quantified
properties over data structures and for computability reasons,  we
have chosen to limit the  actions performed during automaton transitions. 
Simple SLIC specifications are verified by  the SLAM verifier~\cite{dblp:conf/cav/ballr01}.
While SLAM specialises on device drivers and checks client conformance rather than full protocols, 
very general specifications of object-oriented program behaviour can be given in JML~\cite{jml} and Spec$\sharp$~\cite{DBLP:journals/jot/BarnettDFLS04}. However the latter two languages focus on class specifications and do not have temporal features.

In~\cite{disney2011} contracts are used to express legal traces of
programs in a functional language with references. The contracts
specify traces as regular expressions over calls and returns and so
look similar to our automatons, if for a quite different
setting. Here, the specifications are function-centered, though, and
again, capturing inter object relations seems somewhat awkward.


% >>>
\section{Conclusions and Future Work}\label{sec:conclusions} %<<<

This paper presents ongoing work on the design of TOPL---a language for expressing temporal safety properties for object-oriented programs.
TOPL is translated into an intermediate language, iTOPL\null.
The low-level iTOPL is very regular and so its semantics are easy to define.
The high-level TOPL is designed to look familiar to an object-oriented programmer.
More importantly, TOPL curtails iTOPL's expressivity in a way that, we expect, will benefit static verification.
Our implementation helped clarify TOPL's semantics.

We designed TOPL for dynamic and static analysis of Java programs.
The next steps are to develop a dynamic analyzer and a static analyzer.
For dynamic analysis, we intend to instrument Java bytecode and run a checker in parallel with the real program.
The challenge we expect here is to reduce the run-time overhead.
For static analysis, we intend to build on the jStar framework~\cite{DBLP:conf/oopsla/DistefanoP08}.
Remember that TOPL's guards are basically aliasing checks.
Separation logic~\cite{reynolds2002} is a good formalism for reasoning about aliasing and is the foundation of jStar.
The challenges we expect here are convergence and scalability.
For convergence, we must find suitable abstractions, which obtain meaningful and precise over-approximations of the state space of the programs.
For scalability, we may need a tailored version of bi-abduction inference~\cite{dblp:conf/popl/CalcagnoDOY09}.

Another possible development would be to design other high-level property languages on top of iTOPL\null.
For example, it is conceivable that iTOPL could be used as an intermediate language in tools that verify temporal properties of programs written in Haskell~\cite{haskell} or Boogie~\cite{leino2008boogie}.

%>>>

\softraggedright
\bibliographystyle{abbrvnat}
\bibliography{safety}
\end{document}
% vim:spell errorformat=%f\:%l-%m,%f\:%l\:%m,%f\:%m
% vim:fmr=<<<,>>>:
