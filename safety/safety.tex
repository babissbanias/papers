% prelude {{{1
% TeX {{{2
\tracingmacros=0
\overfullrule=5pt
\showboxdepth=10
\showboxbreadth=100
% LaTeX {{{2
\documentclass[a4paper]{article}

% packages {{{3
\usepackage[colorlinks]{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{microtype}
\usepackage{rgalg}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{hyperref}  % solves pdfTeX warning (ext4)?
\usepgflibrary{arrows}
\usepgflibrary{shapes.geometric}  % not supported by ancient TikZ
% metadata and PDF settings {{{3
\title{Checking Safety with Separation Logic}
\author{Dino Distefano \and Radu Grigore}
\definecolor{darkblue}{rgb}{0,0,0.4}
\definecolor{verylightgray}{rgb}{0.9,0.9,0.9}
% comment the next line for printing
\hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkblue}
\hypersetup{
  pdftitle={Checking Safety with Separation Logic},
  pdfauthor={Dino Distefano and Radu Grigore}}
% package customization {{{3
\lstset{
  language=Java,
  basicstyle=\scriptsize,
  identifierstyle=\itshape,
  stringstyle=\footnotesize\ttfamily,
  commentstyle=\textup,
  columns=fullflexible,
  mathescape=true,
  boxpos=t,
  morekeywords={Object}
}
% new commands {{{3
\def\fb#1{{\bf #1}}
\newcommand{\dd}[1]{\todo{dd}{#1}}
\newcommand{\fls}{\bot}
\newcommand{\hoare}[3]{\{#1\}\>\text{#2}\>\{#3\}}
\newcommand{\limp}{\rightarrow}
\newcommand{\rg}[1]{\todo{rg}{#1}}
\newcommand{\todo}[2]{{\small [\textcolor{red}{#1}: #2]}}
\newcommand{\tru}{\top}

%pairs
\newcommand{\startgrammar}{
  \begingroup
  \def\is{$\>\to$&}
  \def\|{$\mid$}
  \def\b##1{\textbf{##1}}
  \def\i##1{\textsl{##1}}
  \def\?{$^?$}
  \def\*{$^\ast$}
  \begin{figure}
  \centering
  \scriptsize
  \begin{tabular}{rl}
}
\newcommand{\stopgrammar}[2]{
  \end{tabular}
  \caption{#1}\label{#2}
  \end{figure}
  \endgroup
}

\newcommand{\bc}{\begin{figure}\centering\begin{tabular}{c}} % begin codebox
\newcommand{\ec}[2]{\end{tabular}\caption{#1}\label{#2}\end{figure}} % end codebox
% new environments (and theorems) {{{3
\newtheoremstyle{slanted}{}{}{\slshape}{}{\bf}{.}{.5em}{}
\theoremstyle{slanted}
\newtheorem{problem}{Problem}
\newtheorem{conjecture}{Conjecture}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem{remark}{Remark}

% body {{{1
\begin{document}
\maketitle
% motivation {{{2
\section{Prior Work and Motivation}

In 2006, SAVCBS organizers challenged participants to specify and verify the Iterator pattern.
Four of the five accepted contributions focused on variations of the following property:
It is forbidden to modify a collection that is being iterated.
The solutions~\cite{cok2006,weide2006,bierhoff2006,krishnaswami2006} vary in the specification language used, degree of automation, expressiveness, and subsequent research they generated.

All solutions used existing specification languages:
Cok used JML~\cite{jml}, Weide used Resolve~\cite{resolve}, Bierhoff used typestates for object-oriented languages~\cite{deline2004}, and Krishnaswami used higher-order separation logic~\cite{biering2007}.

Cok's solution benefits from the existence of a tool, ESC/Java~\cite{escjava}, that statically checks programs annotated with JML\null.
It is not completely clear, as far as we are aware, exactly which subset of JML is handled automatically and soundly by ESC/Java.
However, Cok shows examples of clients of his specification that are handled properly by the tool.
Weide and Bierhoff argue informally that it should be possible to automate their respective approaches;
Krishnaswami argues informally that it should be hard to automate his approach.

No solution is very friendly to programmers. 
Weide's solution works in the setting of a fictitious language, it requires programmers to use at most one iterator at a time, and it requires uses of iterators to be signposted by calls to fictitious methods.
Cok and Bierhoff encode automata in JML and linear logic~\cite{girard1987}, respectively, leaving the burden of decoding the annotations into automata on the code's maintainer.
Krishnaswami uses mathematical concepts and notations that are bound to look unfamiliar to imperative programmers.

There are two important later developments. First, Bierhoff and Aldrich~\cite{bierhoff2007} showed that it is indeed possible to automate the approach based on typestates. Second, Haack and Hurlin~\cite{haack2009} showed how to use first-order separation logic, thereby moving closer to automation as compared to Krishnaswami~\cite{krishnaswami2006}.

There is also an important earlier development, namely the proposal of Trentelman and Huisman~\cite{trentelman2002} to enrich JML with temporal properties~\cite{pnueli1977}.
To see why this is relevant, note that what we want is to forbid executions that contain a call $\iota=\alpha.\mathit{iterator}()$ later followed by $\alpha.\mathit{add}()$ later followed by $\iota.\mathit{next}()$, for some iterator~$\iota$ and some collection~$\alpha$, which clearly has a temporal flavor.
Trentelman and Huisman show by example how safety properties expressed in their extension can also be formulated, more verbosely, in standard JML\null.
In a sense, Cok's solution is another example of expressing a safety property in JML\null.
Unfortunately, we are not aware of any algorithm that translates arbitrary safety properties into JML specifications.
Even if such algorithms are found, the problem of automatically checking JML remains:
The subset of JML that is handled automatically varies from tool to tool, and the descriptions of these subsets tend to be either missing, so complicated that no one can be expected to remember them, or hard to find.
Therefore, it makes sense to search for an algorithm whose target is a very small subset of JML, such that the chances of it being handled by tools are maximized.

An alternative, which we pursue in this article, is to find a translation of safety properties into separation logic, which is a much simpler specification language than JML, and also more rigorously defined~\cite{reynolds2002}. 
As a result, \emph{we obtain a way to turn program verifiers based on separation logic into model checkers of safety properties}.

% background {{{2
\section{Background}

% jstar {{{3
\subsection{Separation Logic and jStar}

% basics of seplogic and jstar
% iterator {{{3
\subsection{The Iterator Pattern}

% you can use seplogic to explain the pattern

Java collections contain Java objects.
The call $c.\mathit{contains}(o)$ returns whether the collection~$c$ contains the object~$o$.
The methods \textit{toArray} and \textit{iterator} allow the content to be inspected as an array and as a stream, respectively.
The optional methods \textit{add} and \textit{remove} modify the collection.

\begin{lstlisting}
interface Collection {
  boolean contains(Object o);
  Object[] toArray();
  Iterator iterator();
  void add(Object o) throws NotSupported;
  void remove(Object o) throws NotSupported;
}
interface Iterator {
  Object next();
  void remove() throws NotSupported;
}
\end{lstlisting}

In a first approximation, Java collections behave like mathematical sets.

A Java collection~$c$ behaves almost like a set:
The call $c.\mathit{contains}(o)$ corresponds to $o\in c$, the call $c.\mathit{add}(o)$ changes the state from~$c$ to $c\cup\{o\}$, the call $c.\mathit{remove}(o)$ may change the state from~$c$ to $c-\{o\}$.
However, this is not quite true.




[Not quite true because of \textit{equals} versus $==$.]
If $i$~is the result of $c.\mathit{iterator}()$ and $o$~is the result of $i.\mathit{next}()$, then $o\in C$.
Some implementations may strengthen the guarantee by saying how many times an object will be returned by \textit{next}, or by saying in which order objects are returned by \textit{next}.
In this paper we will not tackle such specific properties, so for most purposes we may regard collections as sets.
Note, however, that $c.\mathit{contains}(c)$ is not constrained to return \textbf{true}, so it is sometimes important to distinguish between a Java collection~$c$ and its state~$C$ used in the mathematical model.

If $i$ is the result of $c.\mathit{iterator}()$ and $o$ is the (last) result of $i.\mathit{next}()$, then $i.\mathit{remove}()$ behaves almost like $c.\mathit{remove}(o)$.

% model checking {{{3
\subsection{Model Checking}

% LTL, safety, mc idea

% example {{{2
\section{Examples}

% iterator {{{3
% locking {{{3
% file handles {{{3
% theory {{{3
\section{Theory}

% implementation {{{2
\section{Implementation}

% related work {{{2
\section{More Related Work}

\rg{SLAM}

% conclusions {{{2
\section{Conclusions}

% notes {{{2
\section{Notes}

``An \textit{unlock} not preceded by a \textit{lock} is an error.''
Such a property is naturally captured by an automaton.
\begin{equation}
\begin{aligned}
0\to1&: \mathbf{x} = \mathit{makeLock}()\\
1\to\epsilon&: \mathit{unlock}(x)\\
1\to2&: \mathit{lock}(x)\\
2\to1&: \mathit{unlock}(x)
\end{aligned}
\end{equation}
The input to this automaton is the string of method calls from an execution of a program.
Statements that are not method calls are ignored, and so are calls to methods other than \textit{makeLock}, \textit{lock}, and \textit{unlock}.

When the first call to \textit{makeLock} is seen, the automaton variable~$x$ is bound to the return value.
If next comes a call $\mathit{unlock}(y)$, then the automaton checks whether its variable~$x$ holds the same value as that denoted by the Java expression~$y$.
If it fails to decide, then it emits a warning; if it decides that $x=y$, then it takes transition~$1\to\epsilon$, thus signaling an error; if it decides that $x\ne y$, then it stays in state~$1$.

``Locking twice is an error:''
\begin{equation}
\begin{aligned}
0\to1&: \mathit{lock}(\mathbf x)\\
1\to0&: \mathit{unlock}(x)\\
1\to\epsilon&: \mathit{lock}(x)
\end{aligned}
\end{equation}
Here we need not care about \textit{makeLock}.
The reason we did mention it in the previous example is that both sequences $(\mathit{unlock}; \mathit{unlock})$ and $(\mathit{makeLock}; \mathit{unlock})$ are wrong.

``A collection should not be changed while it is being iterated.''
In other words, don't use an iterator after modifying its collection.
\begin{equation}\label{eq:iter1}
\begin{aligned}
0\to1&: \mathbf{i} = \mathit{iterator}(\mathbf{c})\\
1\to2&: \mathit{add}(c, \mathbf{e}) \\
2\to\epsilon&: \mathit{next}(i)
\end{aligned}
\end{equation}
Edges~$1\to2$ should capture all the ways to modify collection~$c$.
It is easy to add edges for methods like $\mathit{Collection}.\mathit{remove}$, but collections may be changed also by $\mathit{Iterator}.\mathit{remove}$.
The iterator~$i$ should not be used further if a call~$\mathit{remove}(j)$ is made with~$i\ne j$.
An automaton with a different structure is better suited for capturing this aspect.
\begin{equation}\label{eq:iter2}
\begin{aligned}
0\to1&: \mathbf{i} = \mathit{iterator}(\mathbf{c})\\
1\to2&: \mathbf{j} = \mathit{iterator}(c)\\
2\to3&: \mathit{remove}(i)\\
2\to4&: \mathit{remove}(j)\\
3\to\epsilon&: \mathit{next}(j)\\
4\to\epsilon&: \mathit{next}(i)
\end{aligned}
\end{equation}

\rg{I need to fix the terminology below. It's confusing.}

We want to check automatically whether a program violates properties specified by such automatons.
To do so, we symbolically execute the automaton in parallel with the program.
The notation $a(1, x\to y)$ means that automaton~$a$ is in state~$1$ and the automaton variable~$x$ is bound to the program expression~$y$.
We say that $a(1,x\to y)$ is an \emph{extended state} of automaton~$a$.
A set of extended states of automatons is attached to a \emph{symbolic state} of a symbolic interpreter to form an \emph{extended symbolic state}.
The \emph{extended symbolic interpreter} knows how to update extended symbolic states, not only simple symbolic states.
We need only a few hooks inside a symbolic interpreter in order to be able to extend it.
We require that the symbolic interpreter (or executioner, if you prefer) implements the following operations.
\begin{align}
\mathit{join} &: \mathit{State} \to \mathit{State} \to \mathit{State} \\
\mathit{execute} &: \mathit{Statement} \to \mathit{State} \to \mathit{State} \\
\mathit{abstract} &: \mathit{State} \to \mathit{State}
\end{align}
In jStar, for example, \textit{join} is logic disjunction, \textit{execute} amounts to doing frame inference and applying the frame rule, and \textit{abstract} applies a set of custom rewrite rules.
The extended versions of these operations have similar types, except that \textit{State} is replaced by \textit{ExtendedState}.

For \textit{join}, we simply take the union of the sets of automaton extended states.
  \[ \mathit{join}'\;(\sigma_1, S_1)\;(\sigma_2,S_2)=
    (\mathit{join}\;\sigma_1\;\sigma_2, S_1\cup S_2) \]

When we execute a statement that labels automaton edges we must also execute those automaton edges.
Here we have the most interesting interaction between the program state and the automaton state.
Take the edge $4\to\epsilon:\mathit{next}(i)$ from~\eqref{eq:iter2}.
Suppose one of the extended automaton states is $a(4,i\to x)$ and the statement to execute is $\mathit{next}(y)$.
The edge is taken if and only if $x=y$.
We therefore need a black box to which we feed the (normal) program state and equality queries.
The black box should answer with `yes', `no', or `I do not know'.
In jStar's case, this black box is the separation logic prover.

% ending {{{2
\bibliographystyle{plain}
\bibliography{safety}
\end{document}
% vim:spell errorformat=%f\:%l-%m,%f\:%l\:%m,%f\:%m

