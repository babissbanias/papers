% prelude {{{
% TeX {{{
\tracingmacros=0
\overfullrule=5pt
\showboxdepth=10
\showboxbreadth=100
% }}}
% LaTeX {{{
\documentclass[a4paper]{article}

% packages {{{
\usepackage[colorlinks]{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{microtype}
\usepackage{rgalg}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{hyperref}  % solves pdfTeX warning (ext4)?
\usepgflibrary{arrows}
%\usepgflibrary{shapes.geometric}  % not supported by ancient TikZ
% }}}
% metadata and PDF settings {{{
\title{Checking Safety with Separation Logic}
\author{Dino Distefano \and Radu Grigore}
\definecolor{darkblue}{rgb}{0,0,0.4}
\definecolor{verylightgray}{rgb}{0.9,0.9,0.9}
% comment the next line for printing
\hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkblue}
\hypersetup{
  pdftitle={Checking Safety with Separation Logic},
  pdfauthor={Dino Distefano and Radu Grigore}}
% }}}
% package customization {{{
\lstset{
  language=Java,
  basicstyle=\scriptsize,
  identifierstyle=\itshape,
  stringstyle=\footnotesize\ttfamily,
  commentstyle=\textup,
  columns=fullflexible,
  mathescape=true,
  boxpos=t,
  morekeywords={Object}
}
% }}}
% new commands {{{
\def\fb#1{{\bf #1}}

\newcommand{\todo}[2]{{\small [\textcolor{red}{#1}: #2]}}
\newcommand{\dd}[1]{\todo{dd}{#1}}
\newcommand{\rg}[1]{\todo{rg}{#1}}
\newcommand{\pmap}{\rightharpoonup}

\theoremstyle{remark}
\newtheorem*{notation}{Notation}

% }}}
% }}}
% }}}
% body {{{
\begin{document}
\maketitle
% motivation {{{
\section{Prior Work and Motivation}

In 2006, SAVCBS organizers challenged participants to specify and verify the Iterator pattern.
Four of the five accepted contributions focused on variations of the following property:
It is forbidden to modify a collection that is being iterated.
The solutions~\cite{cok2006,weide2006,bierhoff2006,krishnaswami2006} vary in the specification language used, degree of automation, expressiveness, and subsequent research they generated.

All solutions used existing specification languages:
Cok used JML~\cite{jml}, Weide used Resolve~\cite{resolve}, Bierhoff used typestates for object-oriented languages~\cite{deline2004}, and Krishnaswami used higher-order separation logic~\cite{biering2007}.

Cok's solution benefits from the existence of a tool, ESC/Java~\cite{escjava}, that statically checks programs annotated with JML\null.
It is not completely clear, as far as we are aware, exactly which subset of JML is handled automatically and soundly by ESC/Java.
However, Cok shows examples of clients of his specification that are handled properly by the tool.
Weide and Bierhoff argue informally that it should be possible to automate their respective approaches;
Krishnaswami argues informally that it should be hard to automate his approach.

No solution is very friendly to programmers. 
Weide's solution works in the setting of a fictitious language, it requires programmers to use at most one iterator at a time, and it requires uses of iterators to be signposted by calls to fictitious methods.
Cok and Bierhoff encode automata in JML and linear logic~\cite{girard1987}, respectively, leaving the burden of decoding the annotations into automata on the code's maintainer.
Krishnaswami uses mathematical concepts and notations that are bound to look unfamiliar to imperative programmers.

There are two important later developments. First, Bierhoff and Aldrich~\cite{bierhoff2007} showed that it is indeed possible to automate the approach based on typestates. Second, Haack and Hurlin~\cite{haack2009} showed how to use first-order separation logic, thereby moving closer to automation as compared to Krishnaswami~\cite{krishnaswami2006}.

There is also an important earlier development, namely the proposal of Trentelman and Huisman~\cite{trentelman2002} to enrich JML with temporal properties~\cite{pnueli1977}.
To see why this is relevant, note that what we want is to forbid executions that contain a call $\iota:=\alpha.\mathit{iterator}()$ later followed by $\alpha.\mathit{add}()$ later followed by $\iota.\mathit{next}()$, for some iterator~$\iota$ and some collection~$\alpha$, which clearly has a temporal flavor.
Trentelman and Huisman show by example how safety properties expressed in their extension can also be formulated, more verbosely, in standard JML\null.
In a sense, Cok's solution is another example of expressing a safety property in JML\null.
Unfortunately, we are not aware of any algorithm that translates arbitrary safety properties into JML specifications.
Even if such algorithms are found, the problem of automatically checking JML remains:
The subset of JML that is handled automatically varies from tool to tool, and the descriptions of these subsets tend to be either missing, so complicated that no one can be expected to remember them, or hard to find.
Therefore, it makes sense to search for an algorithm whose target is a very small subset of JML, such that the chances of it being handled by tools are maximized.

An alternative, which we pursue in this article, is to find a translation of safety properties into separation logic, which is a much simpler specification language than JML, and also more rigorously defined~\cite{reynolds2002}. 
As a result, \emph{we obtain a way to turn program verifiers based on separation logic into model checkers of safety properties}.

% }}}
% background {{{
\section{Background}

% jstar {{{
\subsection{Separation Logic and jStar}
% }}}
% basics of seplogic and jstar
% iterator {{{
\subsection{The Iterator Pattern}

% you can use seplogic to explain the pattern

Java collections contain Java objects.
The call $c.\mathit{contains}(o)$ returns whether the collection~$c$ contains the object~$o$.
The methods \textit{toArray} and \textit{iterator} allow the content to be inspected as an array and as a stream, respectively.
The optional methods \textit{add} and \textit{remove} modify the collection.

\begin{lstlisting}
interface Collection {
  boolean contains(Object o);
  Object[] toArray();
  Iterator iterator();
  void add(Object o) throws NotSupported;
  void remove(Object o) throws NotSupported;
}
interface Iterator {
  Object next();
  void remove() throws NotSupported;
}
\end{lstlisting}

In a first approximation, Java collections behave like mathematical sets.

A Java collection~$c$ behaves almost like a set:
The call $c.\mathit{contains}(o)$ corresponds to $o\in c$, the call $c.\mathit{add}(o)$ changes the state from~$c$ to $c\cup\{o\}$, the call $c.\mathit{remove}(o)$ may change the state from~$c$ to $c-\{o\}$.
However, this is not quite true.




[Not quite true because of \textit{equals} versus $==$.]
If $i$~is the result of $c.\mathit{iterator}()$ and $o$~is the result of $i.\mathit{next}()$, then $o\in C$.
Some implementations may strengthen the guarantee by saying how many times an object will be returned by \textit{next}, or by saying in which order objects are returned by \textit{next}.
In this paper we will not tackle such specific properties, so for most purposes we may regard collections as sets.
Note, however, that $c.\mathit{contains}(c)$ is not constrained to return \textbf{true}, so it is sometimes important to distinguish between a Java collection~$c$ and its state~$C$ used in the mathematical model.

If $i$ is the result of $c.\mathit{iterator}()$ and $o$ is the (last) result of $i.\mathit{next}()$, then $i.\mathit{remove}()$ behaves almost like $c.\mathit{remove}(o)$.
% }}}

% model checking {{{
\subsection{Model Checking}

% LTL, safety, mc idea
% }}}
% }}}
% examples {{{
\section{Examples}

% iterator {{{
% }}}
% locking {{{
% }}}
% file handles {{{
% }}}
% theory {{{
\section{Theory}
% }}}
% }}}
% implementation {{{
\section{Implementation}

% }}}
% related work {{{
\section{More Related Work}

\rg{SLAM}
% }}}
% conclusions {{{
\section{Conclusions}
% }}}
% notes {{{
\section{Notes}

% Plan {{{
%  - properties --- what is checked
%  - Aldrich example - how it's checked, what symbolic execution does
%  - example of executing a statement whose contract is known
%    - program state, show how existential variables are handled
%    - automaton state
%  - abduction for automata, adding transitions to automata
%  - formal description of executing a generic call
%  - desugaring other statements into call
%  - optimizations
%    - constraints on no path to ERROR are forgotten
%    - constraints on all paths to ERROR may prune the automaton state
%  - bigger, more realistic example
% }}}
\subsection{Properties}\label{sec:properties} % {{{

``An \textit{unlock} not preceded by a \textit{lock} is an error.''
Such a property is naturally captured by an automaton.
\begin{equation}\label{eq:unlockunlock}
\begin{aligned}
0\to1&: \mathbf{x} := \mathit{makeLock}()\\
1\to\epsilon&: \mathit{unlock}(x)\\
1\to2&: \mathit{lock}(x)\\
2\to1&: \mathit{unlock}(x)
\end{aligned}
\end{equation}
The input to this automaton is the string of method calls from an execution of a program.
Statements that are not method calls are ignored, and so are calls to methods other than \textit{makeLock}, \textit{lock}, and \textit{unlock}.

When the first call to \textit{makeLock} is seen, the automaton variable~$x$ is bound to the return value.
If next comes a call $\mathit{unlock}(y)$, then the automaton checks whether its variable~$x$ holds the same value as that denoted by the Java expression~$y$.
If it fails to decide, then it emits a warning; if it decides that $x=y$, then it takes transition~$1\to\epsilon$, thus signaling an error; if it decides that $x\ne y$, then it stays in state~$1$.
\rg{We need to discuss when are equalities decidable.}

``Locking twice is an error:''
\begin{equation}
\begin{aligned}
0\to1&: \mathit{lock}(\mathbf x)\\
1\to0&: \mathit{unlock}(x)\\
1\to\epsilon&: \mathit{lock}(x)
\end{aligned}
\end{equation}
Here we need not care about \textit{makeLock}.
The reason we did mention it in the previous example is that both sequences $(\mathit{unlock}; \mathit{unlock})$ and $(\mathit{makeLock}; \mathit{unlock})$ are wrong.

``A collection should not be changed while it is being iterated.''
In other words, don't use an iterator after modifying its collection.
\begin{equation}\label{eq:iter1}
\begin{aligned}
0\to1&: \mathbf{i} := \mathit{iterator}(\mathbf{c})\\
1\to2&: \mathit{add}(c, \mathbf{e}), \mathit{remove}(c, \mathbf{e}), \ldots \\
2\to\epsilon&: \mathit{next}(i), \mathit{hasNext(i)}, \ldots
\end{aligned}
\end{equation}
Edges~$1\to2$ should capture all the ways to modify collection~$c$.
It is easy to add edges for methods like $\mathit{Collection}.\mathit{remove}$, but collections may be changed also by $\mathit{Iterator}.\mathit{remove}$.
The iterator~$i$ should not be used further if a call~$\mathit{remove}(j)$ is made with~$i\ne j$.
An automaton with a different structure is better suited for capturing this aspect.
\begin{equation}\label{eq:iter2}
\begin{aligned}
0\to1&: \mathbf{i} := \mathit{iterator}(\mathbf{c})\\
1\to2&: \mathbf{j} := \mathit{iterator}(c)\\
2\to3&: \mathit{remove}(i)\\
2\to4&: \mathit{remove}(j)\\
3\to\epsilon&: \mathit{next}(j)\\
4\to\epsilon&: \mathit{next}(i)
\end{aligned}
\end{equation}

``An iterator is not advanced past the end of its collection.''
This property involves the constant \textit{true}.
\begin{equation}\label{eq:iter3}
\begin{aligned}
0\to1&: \mathbf{i} := \mathit{iterator}(\mathbf{c}) \\
1\to2&: \mathit{true} := \mathit{hasNext}(i) \\
1\to\epsilon&: \mathit{next}(i) \\
2\to1&: \mathit{next}(i), \ldots
\end{aligned}
\end{equation}
The automaton goes in the safe state~$2$ only when \textit{hasNext} returns~\textit{true}.
It stays in state~$2$ until the first non-pure method is called.

%}}}
\subsection{Overview}\label{sec:overview} % {{{

We check that a program satisfies certain properties by symbolically executing it in parallel with the automaton representations of the properties.
We write $a(2,[e/x,f/y])$ to mean that automaton~$a$ is in state~$2$ with its variable~$x$ bound to the program expression~$e$ and with its variable~$y$ bound to program expression~$f$.
The symbolic interpretor keeps track of a symbolic heap, bit also keeps track of sets like $\{a_1(1,[e/x]), a_1(1,[f/x]), a_2(3)\}$ that record which automaton reached which states and with which bindings.

% }}}
\subsection{Property Checking}\label{sec:property_checking} % {{{

\rg{Explain that Java's $x.y(z)$ and $y(x, z)$ are used interchangeably.}

The properties are similar to typestates.
Indeed, here is how we would check properties \eqref{eq:iter1}~and~\eqref{eq:iter3} on an example from~\cite{bierhoff2007}.
{\def\a#1{a_\text{\ref{eq:iter#1}} }
\begin{lstlisting}
Collection c = new ArrayList();
Iterator i = c.iterator();
// $\a1(1, [i/i, c/c]), \a3(1, [i/i])$
while (i.hasNext() && $\ldots\,$) {
  // $\a1(1, [i/i, c/c]), \a3(2, [i/i])$
  Object o = i.next();
  // $\a1(1, [i/i, c/c]), \a3(1, [i/i])$
  Iterator j = c.iterator();
  // $\a1(1, [i/i, c/c]), \a3(1, [i/i]), \a1(1, [j/i, c/c]), \a3(1, [j/i])$
  while (j.hasNext()) {
    // $\a1(1, [i/i, c/c]), \a3(1, [i/i]), \a1(1, [j/i, c/c]), \a3(2, [j/i])$
    p = j.next();
    // $\a1(1, [i/i, c/c]), \a3(1, [i/i]), \a1(1, [j/i, c/c]), \a3(1, [j/i])$
  }
  // $\a1(1, [i/i, c/c]), \a3(1, [i/i])$
}
// $\a1(1, [i/i, c/c]), \a3(1, [i/i])$
if (i.hasNext()) {
  // $\a1(1, [i/i, c/c]), \a3(2, [i/i])$
  c.remove(i.next());
  // $\a1(2, [i/i, c/c]), \a3(1, [i/i])$
  if (i.hasNext()) {
    // $\a1(\epsilon), \a3(1, [i/i])$
    $\ldots$
  }
}
\end{lstlisting}
At every step we also have $\a1(0)$ and $\a3(0)$, which are not written above, for brevity.}
Similarly, the (non-extended) symbolic state is omitted.
The check of \eqref{eq:iter2} is trivial, because the \textit{remove} method of iterators is never called, so the associated automaton never reaches states 3~and~4.
\rg{Update the example to use generics}

The interesting part of this example is the abstraction taking place at the end of the outer loop.
In general, it is unsound to forget automaton states.
Here, however, it is necessary to reach a fix-point.
Luckily, it is also sound.
Look at state~$a_\text{\ref{eq:iter3}}(1, [j/i])$.
All paths from~$1$ to~$\epsilon$ need to compare $j$ with some other program expression.
But $j$ goes out of scope at the end of the loop and it has no alias, so the state~$a_\text{\ref{eq:iter3}}(1, [j/i])$ can never reach $a_\text{\ref{eq:iter3}}(\epsilon)$.

From an implementation point of view, it might be convenient to avoid introducing the notion of scope.
We would still notice that $j$ becomes unreachable when, in the next iteration, the value of the variable is over-written.
When $j$ turns into the existentially quantified variable $j'$ we can prove that it is not aliased by any non-quantified variable.
\rg{Fill in details; Matko says he implemented a quick conservative check exactly for this.}

\paragraph{Definitions}
In general, a state is \emph{stuck} and may be forgotten if the program expressions to which its relevant automaton variables are bound cannot possibly equal any program expression built out of non-quantified variables.
An automaton variable is \emph{relevant} when it is involved in some check on every path to the error state.

% }}}
\subsection{Operational Semantics and Hoare Triples}\label{sec:opsem} % {{{

Since we execute the automaton as a checker in parallel with the program, we include its state in the semantics.
\begin{align}
\mathsf{State}&=\mathsf{ProgramState}\times\mathsf{AutomatonState} \\
\mathsf{ProgramState}&=\mathsf{Stack}\times\mathsf{Heap} \\
\mathsf{AutomatonState}&=
  (\mathsf{Identifier}\times\mathsf{Stack})\to\mathsf{2} \\
\mathsf{Stack}&=\mathsf{Identifier}\pmap\mathsf{Value} \\
\mathsf{Heap}&=\mathsf{Address}\pmap\mathsf{Value}
\end{align}

\begin{notation}
The notation $\mathsf A\to\mathsf B$ stands for the set of total functions from \textsf A to \textsf B.
The notation $\mathsf A\pmap\mathsf B$ stands for the set of finite partial functions from~$\mathsf A$ to~$\mathsf B$: 
The domain of these functions is a finite subset of~$\mathsf A$.
The notation \textsf 2 stands for the set of booleans, so $\mathsf A\to\mathsf 2$ is (isomorphic to) the power set of~\textsf A.
\end{notation}

Unlike stacks, heaps are indexed by values.
\begin{gather}
\mathsf{Identifier}\cap\mathsf{Value}=\emptyset \\
\mathsf{Address}\subset\mathsf{Value}
\end{gather}

We write $\pi,\tau\vDash P,T$ to mean that $(\pi,\tau)$ is in the subset of \textsf{State} described by~$(P,T)$, where $P$~is a separation logic formula and $T$ is an automaton state.
We say that $(\pi,\tau)$ satisfies $(P,T)$.
\begin{equation}
\pi, \tau \vDash P, T 
  \qquad\text{iff}\qquad
\pi \vDash P
  \quad\text{and}\quad
\tau\supseteq T
\end{equation}
We write $\{P,T\}\;C\;\{P',T'\}$ to mean that if the state before executing~$C$ satisfies $(P,T)$ then the state after executing~$C$ satisfies~$(P',T')$.

% }}}
\subsection{Executing One Statement}\label{sec:execute} % {{{

Let us see in detail how the symbolic interpreter executes a particular statement
\begin{equation}\label{eq:execute.statement}
\mathit{hn}:=j.\mathit{hasNext}()
\end{equation}
when it starts with a particular symbolic heap
\begin{equation}\label{eq:execute.heap}
i=j * \mathit{iter}(i,3) * \mathit{hn} = \mathit{false}
\end{equation}
and a particular set of reached automaton states with their bindings
\begin{equation}\label{eq:execute.props}
\{a_5(1,[i/i]), a_3(2,[k/i])\}.
\end{equation}
Suppose further that the symbolic interpreter is given the contract
\begin{equation}\label{eq:execute.spec}
\{\,\mathit{iter}(x, \mathbf{n})*n>0\,\}
  \quad \mathbf{r} := \mathbf{x}.\mathit{hasNext}()
  \quad \{\,\mathit{iter}(x, n-1)*r=\mathit{true}\,\}.
\end{equation}

\paragraph{The Symbolic Heap} % {{{

The bindings $[\mathit{hn}/r,j/x]$ are found by matching syntactically \eqref{eq:execute.statement} with the statement in~\eqref{eq:execute.spec}, and then the contract is instantiated.
\begin{equation}\label{eq:execute.spec'}
\{\,\mathit{iter}(j, \mathbf{n})*n>0\,\}
  \quad \mathit{hn} := j.\mathit{hasNext}()
  \quad \{\,\mathit{iter}(j, n-1)*\mathit{hn}=\mathit{true}\,\}.
\end{equation}
The substitution $[\mathit{hn}'/\mathit{hn}]$ replaces the variable to which a new value is assigned with a variable that is implicitly existentially quantified.
In general, this substitution is applied to the symbolic heap and also to all program expressions to which automaton variables are bound.
In our case, though, \textit{hn} occurs only in the symbolic heap, which becomes
\begin{equation}\label{eq:execute.heap'}
i=j * \mathit{iter}(i,3) * \mathit{hn} = \mathit{false}.
\end{equation}
Now the (single candidate) binding~$[3/n]$ is found by matching the arguments of \textit{iter} in~\eqref{eq:execute.heap'} and in the precondition of~\eqref{eq:execute.spec'}, and the contract is further specialized.
\begin{equation}\label{eq:execute.spec''}
\{\,\mathit{iter}(j,3)*3>0\,\}\cdots
\{\,\mathit{iter}(j,2)*\mathit{hn}=\mathit{true}\,\}
\end{equation}
At this point, the symbolic interpreter asks the separation logic prover a frame inference question.
Precisely, it asks for a (preferably specific) symbolic heap~$h$ that satisfies
\begin{equation}\label{eq:execute:frame_question}
i=j*\mathit{iter}(i,3)*\mathit{hn}'=\mathit{false}
\;\vdash\;
\mathbf{h}*\mathit{iter}(j,3)*3>0.
\end{equation}
Suppose the prover replies with $[(i=j*\mathit{hn}'=\mathit{false})/h]$.
The frame~$h$ is $*$-joined to the postcondition of~\eqref{eq:execute.spec''}.
\begin{equation}\label{eq:execute.heap''}
i=j*\mathit{hn}'=\mathit{false}*\mathit{iter}(j,2)*\mathit{hn}=\mathit{true}
\end{equation}
This is the symbolic heap after \eqref{eq:execute.statement}~is executed.

% }}}
\paragraph{The Automatons} % {{{

\rg{On the same example.}

% }}}
% }}}
\subsection{Inferring Contracts}\label{sec:infer} % {{{

\rg{Explain how transitions are added to the automatons.}

% }}}
\subsection{Symbolic Execution with Automatons}\label{sec:formal} % {{{

\rg{Present formally what was in the previous sections.}

%}}}
\subsection{Optimizations}\label{sec:optimizations} % {{{

\rg{Explain how some automaton bindings may be dropped.}
\rg{Explain how some deterministic automaton states must be dropped for convergence.}

% }}}
\subsection{Examples}\label{sec:example} % {{{

\rg{Aldrich example}
\rg{lists of uniformly locked mutexes}
\rg{modify list with one iterator, advance with the other}
\rg{others}

% }}}  
\subsection{Issues}\label{sec:issues} % {{{

\begin{itemize}
\item \rg{Make it easy to say ``automaton state doesn't change'' in Hoare triples.}
\item \rg{abduction}
\end{itemize}

% }}}
% }}}
% ending {{{
\bibliographystyle{plain}
\bibliography{safety}
\end{document}
% }}}
% }}}
% vim:spell errorformat=%f\:%l-%m,%f\:%l\:%m,%f\:%m
