% prelude {{{
% TeX {{{
\tracingmacros=0
\overfullrule=5pt
\showboxdepth=10
\showboxbreadth=100
% }}}
% LaTeX {{{
\documentclass[a4paper]{article}

% packages {{{
\usepackage[colorlinks]{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{microtype}
\usepackage{rgalg}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{hyperref}  % solves pdfTeX warning (ext4)?
\usepgflibrary{arrows}
%\usepgflibrary{shapes.geometric}  % not supported by ancient TikZ
% }}}
% metadata and PDF settings {{{
\title{Checking Safety with Separation Logic}
\author{Dino Distefano \and Radu Grigore}
\definecolor{darkblue}{rgb}{0,0,0.4}
\definecolor{verylightgray}{rgb}{0.9,0.9,0.9}
% comment the next line for printing
\hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkblue}
\hypersetup{
  pdftitle={Checking Safety with Separation Logic},
  pdfauthor={Dino Distefano and Radu Grigore}}
% }}}
% package customization {{{
\lstset{
  language=Java,
  basicstyle=\scriptsize,
  identifierstyle=\itshape,
  stringstyle=\footnotesize\ttfamily,
  commentstyle=\textup,
  columns=fullflexible,
  mathescape=true,
  boxpos=t,
  morekeywords={Object}
}
% }}}
% new commands {{{
\def\fb#1{{\bf #1}}

\newcommand{\todo}[2]{{\small [\textcolor{red}{#1}: #2]}}
\newcommand{\dd}[1]{\todo{dd}{#1}}
\newcommand{\rg}[1]{\todo{rg}{#1}}

\newcommand{\pat}{\underline}
\newcommand{\pmap}{\rightharpoonup}
\newcommand{\new}[1]{\text{\textbf{new} \textit{#1}}}

\theoremstyle{remark}
\newtheorem*{notation}{Notation}

% }}}
% }}}
% }}}
% body {{{
\begin{document}
\maketitle
\section{Introduction} % {{{ aka motivation

\rg{Bigger context: temporal properties, model checking, typestates, session types.}

\rg{In SAVCBS, \cite{cok2006,bierhoff2006} basically encode automata in various way. This shows that automata are a natural way to express properties of the Iterator pattern, so it would be nice if users could use automata directly and the encoding would be automatic.}

\rg{\cite{bierhoff2006} and \cite{haack2009} use a fancy implication in linear logic and, respectively, separation logic. \cite{cok2006} uses ghost variables in JML. \cite{trentelman2002} gives a few encodings in JML of temporal properties too. None of these translations from automata are automatic. \cite{krishnaswami2006} does not seem to use automata---check---but the higher order approach is probably not automizable.}

\rg{I think we can use the current encoding with Boogie too, which is cool. (Except Boogie doesn't have contract inference, as done by abduction.)}

\rg{``A way to turn program verifiers based on separation logic into model checkers of safety properties.'' ?}

% }}}
\section{Examples} % {{{
\subsection{Properties}\label{sec:properties} % {{{

``An \textit{unlock} not preceded by a \textit{lock} is an error.''
Such a property is naturally captured by an automaton.
\begin{equation}\label{eq:unlockunlock}
\begin{aligned}
&\mathrm{initial}\to\mathit{unlocked}: &&\pat\alpha := \new{Lock}()\\
&\mathit{unlocked}\to\mathrm{error}: &&\alpha.\mathit{unlock}()\\
&\mathit{unlocked}\to\mathit{locked}: &&\alpha.\mathit{lock}()\\
&\mathit{locked}\to\mathit{unlocked}: &&\alpha.\mathit{unlock}()
\end{aligned}
\end{equation}
This is a nondeterministic automaton: 
The initial state is always active.
The nondeterminism is demonic:
If there is a way to activate the error state the automaton will find it.
When a lock is created its reference is stored in~$\alpha$.
Statement $x.\mathit{lock}()$ triggers its transition if $x=\alpha$;
similarly for $x.\mathit{unlock}()$.

``Locking twice is an error:''
\begin{equation}
\begin{aligned}
&\mathrm{initial}\to\mathit{locked}: &&\pat\alpha.\mathit{lock}()\\
&\mathit{locked}\to\mathrm{initial}: &&\alpha.\mathit{unlock}()\\
&\mathit{locked}\to\mathrm{error}: &&\alpha.\mathit{lock}()
\end{aligned}
\end{equation}

``A collection should not be changed while it is being iterated.''
In other words, don't use an iterator after modifying its collection.
\begin{equation}\label{eq:iter1}
\begin{aligned}
&\mathrm{initial}\to\mathit{iterating}: 
  &&\pat\alpha := \pat\gamma.\mathit{iterator}()\\
&\mathit{iterating}\to\mathit{modified}:
  &&\gamma.\mathit{add}(\pat\ ), 
    \gamma.\mathit{remove}(\pat\ ), \ldots \\
&\mathit{modified}\to\mathrm{error}: 
  &&\alpha.\mathit{next}(), \alpha.\mathit{hasNext}(), \ldots
\end{aligned}
\end{equation}
To check that the collection is not modified through a concurrent iterator we use the following automaton.
\begin{equation}\label{eq:iter2}
\begin{aligned}
&\mathrm{initial}\to\mathit{gotOne}: 
  && \pat\alpha := \pat\gamma.\mathit{iterator}() \\
&\mathit{gotOne}\to\mathit{iterating}: 
  && \pat\beta := \gamma.\mathit{iterator}() \\
&\mathit{iterating}\to\mathit{firstModified}: 
  &&\alpha.\mathit{remove}()\\
&\mathit{firstModified}\to\mathrm{error}: 
  &&\beta.\mathit{next}()\\
&\mathit{iterating}\to\mathit{secondModified}: 
  &&\beta.\mathit{remove}()\\
&\mathit{secondModified}\to\mathrm{error}: 
  &&\alpha.\mathit{next}()
\end{aligned}
\end{equation}

``An iterator is not advanced past the end of its collection.''
This property involves the constant \textit{true}.
\begin{equation}\label{eq:iter3}
\begin{aligned}
&\mathrm{initial}\to\mathit{iterating}: 
  && \pat\alpha := \pat\gamma.\mathit{iterator}() \\
&\mathit{iterating}\to\mathit{hasNext}: 
  &&\mathit{true} := \alpha.\mathit{hasNext}() \\
&\mathit{hasNext}\to\mathit{iterating}: 
  &&\alpha.\mathit{next}() \\
&\mathit{iterating}\to\mathrm{error}: 
  &&\alpha.\mathit{next}() 
\end{aligned}
\end{equation}
The automaton goes in the safe state~$2$ only when \textit{hasNext} returns~\textit{true}.
It stays in state~$2$ until the first non-pure method is called.

\rg{Lists of locks are homogeneous. Or, lists of locks always have
some prefix in state \textit{locked} and the rest is \textit{unlocked}.}

% }}}
\subsection{Property Checking}\label{sec:property_checking} % {{{

The properties are similar to typestates.
Indeed, here is how we would check properties \eqref{eq:iter1}~and~\eqref{eq:iter3} on an example from~\cite{bierhoff2007}.
\begin{lstlisting}
Collection<Integer> c = new ArrayList<Integer>();
Iterator<Integer> i = c.iterator();
// $\mathit{state}=\mathit{iterating}\land\gamma=c\land\alpha=i$
while (i.hasNext() && $\ldots\,$) {
  // $(\mathit{state}=\mathit{iterating}\lor\mathit{state}=\mathit{hasNext})\land\gamma=c\land\alpha=i$
  Integer x = i.next();
  // $\mathit{state}=\mathit{iterating}\land\gamma=c\land\alpha=i$
  Iterator<Integer> j = c.iterator();
  // $\mathit{state}=\mathit{iterating}\land\gamma=c\land(\alpha=i\lor\alpha=j)$
  while (j.hasNext()) {
    // $\gamma=c\land\bigl(\bigl(\mathit{state}=\mathit{iterating}\land(\alpha=i\lor\alpha=j)\bigr)\lor\bigl(\mathit{state}=\mathit{hasNext}\land\alpha=j\bigr)\bigr)$
    p = j.next();
    // $\mathit{state}=\mathit{iterating}\land\gamma=c\land(\alpha=i\lor\alpha=j)$
  }
  // $\mathit{state}=\mathit{iterating}\land\gamma=c\land\alpha=i$
}
// $\mathit{state}=\mathit{iterating}\land\gamma=c\land\alpha=i$
if (i.hasNext()) {
  // $(\mathit{state}=\mathit{iterating}\lor\mathit{state}=\mathit{hasNext})\land\gamma=c\land\alpha=i$
  c.remove(i.next());
  // $(\mathit{state}=\mathit{iterating}\lor\mathit{state}=\mathit{modified})\land\alpha=i$
  if (i.hasNext()) {
    // $(\mathit{state}=\mathrm{error}\lor\mathit{state}=\mathit{hasNext})\land\alpha=i$
    $\ldots$
  }
}
\end{lstlisting}
\rg{assume states are distinct}
\rg{Should be $\mathit{state}=\mathrm{initial}\lor\cdots$ but it's long.}
\rg{Add points-to.}
The check of \eqref{eq:iter2} is trivial, because the \textit{remove} method of iterators is never called, so the associated automaton never reaches states 3~and~4.

The interesting part of this example is the abstraction taking place at the end of the outer loop.
In general, it is unsound to forget automaton states.
Here, however, it is necessary to reach a fix-point.
Luckily, it is also sound.
Look at state~$a_\text{\ref{eq:iter3}}(1, [j/i])$.
All paths from~$1$ to~$\epsilon$ need to compare $j$ with some other program expression.
But $j$ goes out of scope at the end of the loop and it has no alias, so the state~$a_\text{\ref{eq:iter3}}(1, [j/i])$ can never reach $a_\text{\ref{eq:iter3}}(\epsilon)$.

From an implementation point of view, it might be convenient to avoid introducing the notion of scope.
We would still notice that $j$ becomes unreachable when, in the next iteration, the value of the variable is over-written.
When $j$ turns into the existentially quantified variable $j'$ we can prove that it is not aliased by any non-quantified variable.
\rg{Fill in details; Matko says he implemented a quick conservative check exactly for this.}

\paragraph{Definitions}
In general, a state is \emph{stuck} and may be forgotten if the program expressions to which its relevant automaton variables are bound cannot possibly equal any program expression built out of non-quantified variables.
An automaton variable is \emph{relevant} when it is involved in some check on every path to the error state.

% }}}
\subsection{Others} % {{{

\rg{Aldrich example}
\rg{lists of uniformly locked mutexes}
\rg{modify list with one iterator, advance with the other}
\rg{others}
 
% }}}
% }}}
\section{Theory} % {{{
\subsection{Operational Semantics and Hoare Triples}\label{sec:opsem} % {{{

\rg{Simplify this according to discussion with Hongseok.}

Since we execute the automaton as a checker in parallel with the program, we include its state in the semantics.
\begin{align}
\mathsf{State}&=\mathsf{ProgramState}\times\mathsf{AutomatonState} \\
\mathsf{ProgramState}&=\mathsf{Stack}\times\mathsf{Heap} \\
\mathsf{AutomatonState}&=\mathsf{Identifier}\times\mathsf{Stack} \\
\mathsf{Stack}&=\mathsf{Identifier}\pmap\mathsf{Value} \\
\mathsf{Heap}&=\mathsf{Address}\pmap\mathsf{Value}
\end{align}

Unlike stacks, heaps are indexed by values.
\begin{gather}
\mathsf{Identifier}\cap\mathsf{Value}=\emptyset \\
\mathsf{Address}\subset\mathsf{Value}
\end{gather}

We write $\pi,\tau\vDash P,T$ to mean that $(\pi,\tau)$ is in the subset of \textsf{State} described by~$(P,T)$, where $P$~is a separation logic formula and $T$ is an automaton state.
We say that $(\pi,\tau)$ satisfies $(P,T)$.
\begin{equation}
\pi, \tau \vDash P, T 
  \qquad\text{iff}\qquad
\pi \vDash P
  \quad\text{and}\quad
\tau\in T
\end{equation}
We write $\{P,T\}\;C\;\{P',T'\}$ to mean that if the state before executing~$C$ satisfies $(P,T)$ then the state after executing~$C$ satisfies~$(P',T')$.

% }}}
\subsection{Other Stuff} % {{{

\rg{language for describing automata}
\rg{soundness of translating automata in Hoare triples?}
\rg{inferring contracts (abduction)}
\rg{Must discuss what happens with equalities that can't be decided.}

% }}}
% }}}
\section{Implementation} % {{{

\rg{Explain how some automaton bindings may be dropped.}
\rg{Explain how some deterministic automaton states must be dropped for convergence.}
\rg{error traces?}

% }}}
\section{Related Work} % {{{

\rg{SLAM}
\rg{session types}
\rg{Jules' communicating automata}
\rg{Java Pathfinder?}
\rg{Frama-C's Aroa\"\i}

% }}}
\section{Conclusions} % {{{

% }}}
% ending {{{
\bibliographystyle{plain}
\bibliography{safety}
\end{document}
% }}}
% }}}
% vim:spell errorformat=%f\:%l-%m,%f\:%l\:%m,%f\:%m
