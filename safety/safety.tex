% prelude {{{
% TeX {{{
\tracingmacros=0
\overfullrule=5pt
\showboxdepth=10
\showboxbreadth=100
% }}}
% LaTeX {{{
\documentclass[a4paper]{article}

% packages {{{
\usepackage[colorlinks]{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{microtype}
\usepackage{rgalg}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{hyperref}  % solves pdfTeX warning (ext4)?
\usepgflibrary{arrows}
%\usepgflibrary{shapes.geometric}  % not supported by ancient TikZ
% }}}
% metadata and PDF settings {{{
\title{Checking Safety with Separation Logic}
\author{Dino Distefano \and Radu Grigore \and Rasmus Lerchedahl Petersen}
\definecolor{darkblue}{rgb}{0,0,0.4}
\definecolor{verylightgray}{rgb}{0.9,0.9,0.9}
% comment the next line for printing
\hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkblue}
\hypersetup{
  pdftitle={Checking Safety with Separation Logic},
  pdfauthor={Dino Distefano and Radu Grigore and Rasmus Lerchedahl Petersen}}
% }}}
% package customization {{{
\lstset{
  language=Java,
  basicstyle=\scriptsize,
  identifierstyle=\itshape,
  stringstyle=\footnotesize\ttfamily,
  commentstyle=\textup,
  columns=fullflexible,
  mathescape=true,
  boxpos=t,
  morekeywords={Object}
}
% }}}
% new commands {{{
\def\fb#1{{\bf #1}}

\newcommand{\todo}[2]{{\small [\textcolor{red}{#1}: #2]}}
\newcommand{\dd}[1]{\todo{dd}{#1}}
\newcommand{\rg}[1]{\todo{rg}{#1}}

\newcommand{\pat}{\underline}
\newcommand{\pmap}{\rightharpoonup}
\newcommand{\new}[1]{\text{\textbf{new} \textit{#1}}}

\theoremstyle{remark}
\newtheorem*{notation}{Notation}

% }}}
% }}}
% body {{{
\begin{document}
\maketitle
\section{Introduction} % {{{ aka motivation

\rg{Bigger context: temporal properties, model checking, typestates, session types.}

\rg{In SAVCBS, \cite{cok2006,bierhoff2006} basically encode automata in various way. This shows that automata are a natural way to express properties of the Iterator pattern, so it would be nice if users could use automata directly and the encoding would be automatic.}

\rg{\cite{bierhoff2006} and \cite{haack2009} use a fancy implication in linear logic and, respectively, separation logic. \cite{cok2006} uses ghost variables in JML. \cite{trentelman2002} gives a few encodings in JML of temporal properties too. None of these translations from automata are automatic. \cite{krishnaswami2006} does not seem to use automata---check---but the higher order approach is probably not automizable.}

\rg{I think we can use the current encoding with Boogie too, which is cool. (Except Boogie doesn't have contract inference, as done by abduction. But it could be done globally.)}

\rg{``A way to turn program verifiers based on separation logic into model checkers of safety properties.'' ?}

% }}}
\section{Examples} % {{{
\subsection{Properties}\label{sec:properties} % {{{

``An \textit{unlock} not preceded by a \textit{lock} is an error.''
Such a property is naturally captured by an automaton.
\begin{equation}\label{eq:unlockunlock}
\begin{aligned}
&\mathrm{initial}\to\mathit{unlocked}: &&\pat\alpha := \new{Lock}()\\
&\mathit{unlocked}\to\mathrm{error}: &&\alpha.\mathit{unlock}()\\
&\mathit{unlocked}\to\mathit{locked}: &&\alpha.\mathit{lock}()\\
&\mathit{locked}\to\mathit{unlocked}: &&\alpha.\mathit{unlock}()
\end{aligned}
\end{equation}
This is a nondeterministic automaton:
The initial state is always active.
The nondeterminism is demonic:
If there is a way to activate the error state the automaton will find it.
When a lock is created its reference is stored in~$\alpha$.
Statement $x.\mathit{lock}()$ triggers its transition if $x=\alpha$;
similarly for $x.\mathit{unlock}()$.

``Locking twice is an error:''
\begin{equation}
\begin{aligned}
&\mathrm{initial}\to\mathit{locked}: &&\pat\alpha.\mathit{lock}()\\
&\mathit{locked}\to\mathrm{initial}: &&\alpha.\mathit{unlock}()\\
&\mathit{locked}\to\mathrm{error}: &&\alpha.\mathit{lock}()
\end{aligned}
\end{equation}

``A collection should not be changed while it is being iterated.''
In other words, don't use an iterator after modifying its collection.
\begin{equation}\label{eq:iter1}
\begin{aligned}
&\mathrm{initial}\to\mathit{iterating}:
  &&\pat\alpha := \pat\gamma.\mathit{iterator}()\\
&\mathit{iterating}\to\mathit{modified}:
  &&\gamma.\mathit{add}(\pat\ ),
    \gamma.\mathit{remove}(\pat\ ), \ldots \\
&\mathit{modified}\to\mathrm{error}:
  &&\alpha.\mathit{next}(), \alpha.\mathit{hasNext}(), \ldots
\end{aligned}
\end{equation}
To check that the collection is not modified through a concurrent iterator we use the following automaton.
\begin{equation}\label{eq:iter2}
\begin{aligned}
&\mathrm{initial}\to\mathit{gotOne}:
  && \pat\alpha := \pat\gamma.\mathit{iterator}() \\
&\mathit{gotOne}\to\mathit{iterating}:
  && \pat\beta := \gamma.\mathit{iterator}() \\
&\mathit{iterating}\to\mathit{firstModified}:
  &&\alpha.\mathit{remove}()\\
&\mathit{firstModified}\to\mathrm{error}:
  &&\beta.\mathit{next}()\\
&\mathit{iterating}\to\mathit{secondModified}:
  &&\beta.\mathit{remove}()\\
&\mathit{secondModified}\to\mathrm{error}:
  &&\alpha.\mathit{next}()
\end{aligned}
\end{equation}

``An iterator is not advanced past the end of its collection.''
This property involves the constant \textit{true}.
\begin{equation}\label{eq:iter3}
\begin{aligned}
&\mathrm{initial}\to\mathit{iterating}:
  && \pat\alpha := \pat\gamma.\mathit{iterator}() \\
&\mathit{iterating}\to\mathit{hasNext}:
  &&\mathit{true} := \alpha.\mathit{hasNext}() \\
&\mathit{hasNext}\to\mathit{iterating}:
  &&\alpha.\mathit{next}() \\
&\mathit{iterating}\to\mathrm{error}:
  &&\alpha.\mathit{next}()
\end{aligned}
\end{equation}
The automaton goes in the safe state~$2$ only when \textit{hasNext} returns~\textit{true}.
It stays in state~$2$ until the first non-pure method is called.

\rg{Lists of locks are homogeneous. Or, lists of locks always have
some prefix in state \textit{locked} and the rest is \textit{unlocked}.}

% }}}
\subsection{Property Checking}\label{sec:property_checking} % {{{

The properties are similar to typestates.
Indeed, here is how we would check properties \eqref{eq:iter1}~and~\eqref{eq:iter3} on an example from~\cite{bierhoff2007}.
\begin{lstlisting}
Collection<Integer> c = new ArrayList<Integer>();
Iterator<Integer> i = c.iterator();
// $\mathit{state}=\mathit{iterating}\land\gamma=c\land\alpha=i$
while (i.hasNext() && $\ldots\,$) {
  // $(\mathit{state}=\mathit{iterating}\lor\mathit{state}=\mathit{hasNext})\land\gamma=c\land\alpha=i$
  Integer x = i.next();
  // $\mathit{state}=\mathit{iterating}\land\gamma=c\land\alpha=i$
  Iterator<Integer> j = c.iterator();
  // $\mathit{state}=\mathit{iterating}\land\gamma=c\land(\alpha=i\lor\alpha=j)$
  while (j.hasNext()) {
    // $\gamma=c\land\bigl(\bigl(\mathit{state}=\mathit{iterating}\land(\alpha=i\lor\alpha=j)\bigr)\lor\bigl(\mathit{state}=\mathit{hasNext}\land\alpha=j\bigr)\bigr)$
    Integer y = j.next();
    // $\mathit{state}=\mathit{iterating}\land\gamma=c\land(\alpha=i\lor\alpha=j)$
  }
  // $\mathit{state}=\mathit{iterating}\land\gamma=c\land\alpha=i$
}
// $\mathit{state}=\mathit{iterating}\land\gamma=c\land\alpha=i$
if (i.hasNext()) {
  // $(\mathit{state}=\mathit{iterating}\lor\mathit{state}=\mathit{hasNext})\land\gamma=c\land\alpha=i$
  c.remove(i.next());
  // $(\mathit{state}=\mathit{iterating}\lor\mathit{state}=\mathit{modified})\land\alpha=i$
  if (i.hasNext()) {
    // $(\mathit{state}=\mathrm{error}\lor\mathit{state}=\mathit{hasNext})\land\alpha=i$
  }
}
\end{lstlisting}
Comment $p$ abbreviates the symbolic state $(p\lor\mathit{state}=\mathrm{initial})\land q$, where $q$ is the program state.
For example, after the first two statements, $q$ might be $c\mapsto-*i\mapsto-$.
If the prover cannot show that a symbolic state implies $\mathit{state}\ne\mathrm{error}$ (given that the possible values of the automaton \textit{state} are distinct), then a warning is printed.

Observe that a new iterator~$j$ is allocated at each iteration of the outer loop.
In order to reach a fix-point, the symbolic state keeps track only of the~$j$ of the current iteration.
This is sound only because the iterators allocated in previous iterations are unreachable, so they cannot be advanced.
In general, to reach a fix-point we will occasionally need to strengthen the symbolic state and we will need to show under what circumstances it is safe to do so.

% }}}
\subsection{Encoding} % {{{



%}}}
\subsection{Others} % {{{

\rg{Aldrich example}
\rg{lists of uniformly locked mutexes}
\rg{modify list with one iterator, advance with the other}
\rg{others}

% }}}
% }}}
\section{Theory} % {{{

We start with a simple language and a simple execution model, close to the ones usually used with separation logic.
We continue with the syntax and semantics of our automatons.
Finally, we give a sound encoding of automatons into the basic execution model.

\subsection{Programming Language and Execution Model} % {{{

The program's state is determined by the content of the memory.
\begin{align}
\mathsf{ProgramState}&=\mathsf{Stack}\times\mathsf{Heap} \\
\mathsf{Stack}&=\mathsf{Identifier}\pmap\mathsf{Value} \\
\mathsf{Heap}&=\mathsf{Address}\pmap\mathsf{Value}
\end{align}
Unlike stacks, heaps are indexed by values.
\begin{gather}
\mathsf{Identifier}\cap\mathsf{Value}=\emptyset \\
\mathsf{Address}\subset\mathsf{Value}
\end{gather}
Statements may be nondeterministic.
\begin{equation}
\mathsf{Statement}\subseteq\mathsf{ProgramState}\times\mathsf{ProgramState}
\end{equation}

% }}}

\subsection{Automaton Syntax and Semantics} % {{{

% }}}

\subsection{Encoding and Soundness} % {{{

% }}}

\subsection{Other Stuff} % {{{

\rg{language for describing automata}
\rg{soundness of translating automata in Hoare triples?}
\rg{inferring contracts (abduction)}
\rg{Must discuss what happens with equalities that can't be decided.}

% }}}
% }}}
\section{Implementation} % {{{

\rg{Explain how some automaton bindings may be dropped.}
\rg{Explain how some deterministic automaton states must be dropped for convergence.}
\rg{error traces?}

% }}}
\section{Related Work} % {{{

\rg{SLAM}
\rg{session types}
\rg{Jules' communicating automata}
\rg{Java Pathfinder?}
\rg{Frama-C's Aroa\"\i}

% }}}
\section{Conclusions} % {{{

% }}}
% ending {{{
\bibliographystyle{plain}
\bibliography{safety}
\end{document}
% }}}
% }}}
% vim:spell errorformat=%f\:%l-%m,%f\:%l\:%m,%f\:%m
