\documentclass{llncs} % <<<


\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{amsthm}
\usepackage{graphics}
\usepackage[latin1]{inputenc}
\usepackage{microtype}  % do not remove
\usepackage{pygmentize}
\usepackage{rgalg}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{proof}

\usepackage{tikz}
\usetikzlibrary{arrows,positioning,fit,backgrounds,shadows,calc}

\usepackage[colorlinks]{hyperref} % keep it last to avoid some warnings

\RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}
\definecolor{darkred}{rgb}{0.4,0,0}
\definecolor{darkblue}{rgb}{0,0,0.4}
\definecolor{verylightgray}{rgb}{0.9,0.9,0.9}
\definecolor{lightblue}{rgb}{0,0,0.9}
% comment the next line for printing
\hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkblue}
%\hypersetup{
%  pdftitle={TOPL: A Language for Specifying Safety Temporal Properties of Object-Oriented Programs},
%  pdfauthor={Radu Grigore and Rasmus Lerchedahl Petersen and Dino Distefano}}

\newcommand{\TPL}{TOPL}

\title{Dynamic Checking of Temporal Safety properties for Java}
\author{Dino Distefano \and Radu Grigore \and Rasmus Lerchedahl Petersen}


\institute{Queen Mary University of London }


%\title{Dynamic Checking of Temporal Safety properties for Java}
%\authorinfo{Authors info whitheld for double-blind submission}
%\authorinfo{Dino Distefano}
%           {Queen Mary University of London}
%           {ddino@eecs.qmul.ac.uk}
%\authorinfo{Radu Grigore}
%           {Queen Mary University of London}
%           {rgrig@eecs.qmul.ac.uk}
%\authorinfo{Rasmus Lerchedahl Petersen}
%           {Queen Mary University of London}
%           {rusmus@eecs.qmul.ac.uk}


% rg: I tend to give grammars in BFS order
\def\grammar#1{{
  \footnotesize
  \def\b##1{{\rm\Verb@##1@}}\def\*{$^*$}\def\?{$^?$}\def\({$($}\def\){$)$}
  \def\|{$\mid$}\def\+{$^+$}
  \smallskip
  \hbox to\hsize{\hfil\vbox{\halign{\hfil\it##&$\;::=\;$\it##\hfil&\qquad\rm##\hfil\cr#1}}\hfil}
  \smallskip
}}

\renewcommand{\sectionautorefname}{Section}
\renewcommand{\subsectionautorefname}{\sectionautorefname}

\newcommand{\noterg}[2]{\textcolor{gray}{[\textcolor{red}{#1}: #2]}}
%\renewcommand{\note}[2]{}
\newcommand{\rg}[1]{\noterg{rg}{#1}}
\newcommand{\rlp}[1]{\noterg{rlp}{#1}}
\newcommand{\dd}[1]{\noterg{dd}{#1}}
\newcommand{\dinocomment}[1]{\dd{#1}}

\newcommand{\B}{\ensuremath{\mathbb{B}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\delimitVerbatim}{\par\nobreak\smallskip\noindent}
\newcommand{\error}{\ensuremath{\textcolor{darkred}{\mathtt{error}}}\xspace}
\newcommand{\eval}[1]{[[#1]]}
\newcommand{\pattern}[1]{\ensuremath{\mathtt{\underline{#1}}}}
\newcommand{\pmap}{\rightharpoonup}
\newcommand{\set}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\start}{\ensuremath{\mathtt{start}}\xspace}
\newcommand{\verbline}[2][]{\[\text{\Verb@#2@}#1\]}

\newcommand{\functionfont}[1]{\mathit{#1}}
\newcommand{\desugar}{\functionfont{des}}
\newcommand{\enabled}{\functionfont{enabled}}

\newcommand{\codefont}[1]{\mathtt{#1}}
\newcommand{\this}{\codefont{this}}

%\newtheorem{theorem}{Theorem}
%\newtheorem{definition}{Definition}
%\newtheorem{lemma}{Lemma}
%\newtheorem{example}{Example}
\newtheorem{notation}{Notation}



%\overfullrule=5pt
%\showboxdepth=10
%\showboxbreadth=30
% >>>
\begin{document}
\maketitle

\begin{abstract} % <<<
We introduce a new technique for checking, at run-time, temporal safety properties of Java programs.
Our approach is based on a new general specification language able to express complex properties of 
systems involving multiple interacting objects. The specifications are then used to instrument Java byte-code so that their violations can be automatically detected at run-time. 
We have validated our technique by checking several safety properties on large open source projects.
\end{abstract}
%\begin{IEEEkeywords}
%Safety, Temporal Properties, Object-Oriented, Dynamic Checking
%\end{IEEEkeywords}

%\category{D.2.1}{Software Engineering}{Requirements/Specifications}
%\terms Languages, Verification
%\keywords Safety, Temporal Properties, Object-Oriented

% >>>
\section{Introduction} % <<<

Objects interaction is at the core of the object-oriented paradigm. When designing object-oriented software, 
programmers have often  a global picture of the co-operation that objects will have in different moments in time and the 
invariants that all the player should adhere to for the correct functioning of the system.
These invariants are often naturally expressible as {\em temporal safety properties}, a field extensively 
studied in several contexts by both the formal methods and the verification community. 
%
In this article, we focus on the automatic run-time checking of safety temporal properties in an object-oriented setting. 
%One first difficulty in attacking this problem is a suitable formal specification language which takes into account the %peculiarities of object-oriented programming. 
Consider for  example  Java collections. A typical property one would want to state is:
\begin{quote}
{\em If one iterator modifies its collection, then other existing iterators of the same collection become invalid and cannot be used.}
\end{quote}
\noindent
The formalization of the above constraint is non-trivial since it 
needs to keep track of {\em several objects} (at least two iterators, and one collection) and their {\em interaction}.
Although several existing specification languages for safety temporal properties of object-oriented software do exist~\cite{strom1986,dblp:conf/oopsla/bierhoffa07,dblp:conf/oopsla/naeeml08,disney2011,ball2002},
they do not allow expressing the interaction involved in properties like the above in a straightforward manner. 
%It seems therefore worthwhile to attempt to define a different language which would make this task easier.  
For this reasons,  we have defined  \TPL\ (Temporal Object-oriented Property Language).
%Bierhoff and Aldrich~\cite{dblp:conf/oopsla/bierhoffa07} as well as Naeem and Lhot\'ak~\cite{dblp:conf/oopsla/naeeml08} use specification languages inspired by typestates~\cite{strom1986}.
%Specifically, Bierhoff and Aldrich~\cite{dblp:conf/oopsla/bierhoffa07} use a combination of linear logic~\cite{dblp:journals/tcs/girard87} and access permissions, while Naeem and Lhot\'ak~\cite{dblp:conf/oopsla/naeeml08} use tracematches.
%Disney et al.~\cite{disney2011} use a language based on regular grammars to specify higher-order temporal contracts.
%Finally, Ball and Rajamani~\cite{ball2002} essentially use nondeterministic aspect-oriented programming.
%
\TPL \ takes inspiration from several of such existing  languages, but it allows 
to naturally express  the relationships and interactions among several objects.
Most of the existing techniques aim at decomposing properties involving several objects into specifications reflecting the point of view of {\em one} single object.
In contrast, TOPL intentionally avoids such decomposition.
Parkinson~\cite{parkinson-iwaco2007} argues that invariants involving several objects are often better than one-object invariants. 
Similarly, we believe that temporal properties that naturally involve a plurality of objects are easier to express and reason about if they are \emph{not} decomposed. 
In this way,  
TOPL helps in  reducing the semantic gap between 
the intuitive understanding that programmers have of various temporal constraints on their code 
and the precise formal description needed by verification/analysis tools for automatic checking of these constraints.



One language in the literature sharing this point of view is tracematches~\cite{DBLP:conf/oopsla/AllanACHKLMSST05}. However, TOPL is strictly more expressive than tracematches as it allow, for example, to encode properties involving overwrite of values or shapes of dynamic allocated data structures (e.g., cyclic vs acyclic linked list, etc) often crucial for object-oriented systems.

%Moreover, by being high-level,  
%TOPL helps in  reducing the semantic gap between 
%the intuitive understanding that programmers have of various temporal constraints on their code 
%and the precise formal description needed by verification/analysis tools for automatic checking of these constraints.

Having defined how to specify temporal properties in a convenient  and formal way, 
we introduce a technique for automatically checking them at run-time on Java programs.
Our method involves instrumenting the Java byte code in a way it reflects the TOPL property of interest.
Automatic run-time checking of TOPL properties is beneficial for the programmer as
 it relieves him/her from the burden of 
interspersing the code with ad-hoc checks  aimed at tracing the violation of a correct temporal behaviour.
The Java API, for example, has hand-crafted code for checking certain temporal properties (\autoref{sec:examples.steps}).
However, such checks are often hard to write, weaved with the code solving the actual problem, and | in the case of the Java API |  do not provide with a trace of the relevant events leading to an error.
In contrast, dynamically checking TOPL properties  with the technique we present in this paper is transparent to the programmer and, therefore,  it avoids all these issues.

In summary, the contributions of this paper are:
\begin{itemize}
\item The definition of TOPL, a new temporal specification language tailored to object-oriented software able to express properties involving several objects and their relations/interactions.
\item For TOPL we have defined a precise formal semantics making the language suitable for program analysis (both static and dynamic) and verification. 
\item We introduce a technique to automatically check at run-time violations of TOPL properties in Java programs.
\item We have implemented our technique and we report experiments on large open source projects.
\end{itemize}

The paper is organized as follows. In Section~\ref{sec:examples} we start with few motivating examples.
Section~\ref{sec:syntax} gives  \TPL's syntax  and semantics.
Section~\ref{sec:dynamic} explores the use of \TPL \ for run-time checking of and presents experimental results. Section~\ref{sec:related} discusses related work.
Finally, Section~\ref{sec:conclusions} concludes the paper and describes our plans for future work.




% >>>
\section{TOPL by Examples} \label{sec:examples} % <<<
In this section we introduce TOPL in an informal way by means of examples.
%The first example (\autoref{sec:examples.steps}) uses a large part of \TPL\null.
%Each execution step introduces a few new concepts.
%The other examples (Sections~\ref*{sec:examples.iterators}--\ref*{sec:examples.ho}) illustrate TOPL expressiveness.


\subsection{Iterators Step by Step} \label{sec:examples.steps} % <<<
The informal safety property in the introduction can be better restated as:
\begin{quote}
\emph{Modifying a collection through an iterator invalidates other iterators for the same collection}.
\end{quote}
\noindent
The last statement in \autoref{fig:first.java} violates this property, therefore throwing an exception.
There are two iterators on the same collection, one of them modifies the collection, and this invalidates the other iterator.
Such properties are often explained using diagrams that are sometimes precise, but not expressive enough~\cite{dblp:journals/scp/FieldGRY05,dblp:conf/issta/FinkYDRG06} or sometimes expressive, but imprecise~\cite{dblp:conf/oopsla/bierhoffa07,dblp:conf/oopsla/naeeml08,dblp:conf/sigsoft/boddenlh08,dblp:conf/ecoop/bierhoffba09}.
%\dinocomment{what does it mean exactly? That they do not have defined formal semantics?}
\autoref{fig:first.topl} (left)  captures precisely a temporal property involving three interacting objects.
On the right hand side  the same property is described in TOPL's textual form of TOPL isomorphic to the diagram.

In a TOPL property, vertices have identifiers (\texttt{start}, \texttt{one}, \texttt{two}, \dots);
transitions have labels ($\pattern I:=\pattern C.\mathtt{iterator}()$, \dots).
There are two special vertices: \start, from where the execution begins; and \error, where the execution ends.
Labels resemble the shape of statements that enable the corresponding transition.

\begin{figure} % first example <<<
\include{IncorrectIteratorUse}
\caption{A first example: Java code}
\label{fig:first.java}
\end{figure}
%
\begin{figure}
\begin{tikzpicture}
  \def\x{2.5}
  \def\y{1.5}
  \tikzset{vertex/.style={draw,circle,inner sep=1pt}}
  \tikzset{transition/.style={->,>=latex}}
  \tikzset{every label/.style={gray}}
  \node[vertex] (start) at (0,0) [label=left:\texttt{start}] {};
  \node[vertex] (one) at (0,-1*\y) [label=left:\texttt{one}] {};
  \node[vertex] (two) at (0,-2*\y) [label=below:\texttt{two}] {};
  \node[vertex] (xBad) at (1*\x,-2.5*\y) [label=right:\texttt{xBad}] {};
  \node[vertex] (yBad) at (-1*\x,-2.5*\y) [label=left:\texttt{yBad}] {};
  \node[vertex,fill=darkred] (error) at (0,-3*\y) [label=below:\textcolor{darkred}{\texttt{error}}] {};
  \draw[transition] (0,0.5)--(start);
  \draw[transition] (start)--node[right]{$\pattern X:=\pattern C.\mathtt{iterator}()$} (one);
  \draw[transition] (one) .. controls +(30:1cm) and +(-30:1cm) .. node[right]{$*$} (one);
  \draw[transition] (one)--node[right]{$\pattern Y:=\pattern c.\mathtt{iterator}()$} (two);
  \draw[transition] (two) -- node[sloped,above]{$\pattern y.\mathtt{remove}()$} (xBad);
  \draw[transition] (two)--node[sloped,above]{$\pattern x.\mathtt{remove}()$} (yBad);
  \draw[transition] (xBad)--node[sloped,below]{$\mathtt{call}\;\pattern x.{*}[*]$} (error);
  \draw[transition] (yBad)--node[sloped,below]{$\mathtt{call}\;\pattern y.{*}[*]$} (error);
\end{tikzpicture}
%\\[2ex]
\begin{Verbatim}[commandchars=\\\{\}]
property InvalidateOtherIterators
  using prefix java.util.Collection
  using prefix java.util.Iterator
  start -> one:  \pattern{X} := \pattern{C}.iterator()
  one -> one:    *
  one -> two:    \pattern{Y} := \pattern{c}.iterator()
  two -> yBad:   \pattern{x}.remove()
  two -> xBad:   \pattern{y}.remove()
  yBad -> error: call \pattern{y}.*[*]
  xBad -> error: call \pattern{x}.*[*]
\end{Verbatim}    
\caption{The property {\tt InvalidateOtherIterators} in diagram (left) and textual form (right).
}
\label{fig:first.topl}
\end{figure}
%
\begin{figure}
{\def\s#1{\text{\Verb@#1@}}
 \def\m#1{\PY{n+na}{#1}}
 \def\t#1{\mathtt{#1}}
\begin{align*}
&\{\;(\start,[])\;\} \\
&\s{Iterator<Integer> i = c.\m{iterator}();} \quad
\text{//assume {\tt c} holds $1$, and {\tt i} holds $2$ } \\
& \begin{aligned}
  \{\;&(\start,[]),\
      &(\t{one},[c:1,x:2])\;\}
  \end{aligned}\\
&\s{Iterator<Integer> j = c.\m{iterator}();} \quad
\text{//assume {\tt j} holds $3$} \\
& \begin{aligned}
  \{\;&(\start,[]),\
      &(\t{one},[c:1,x:2]),\
      &(\t{one},[c:1,x:3]),\
      &(\t{two},[c:1,x:2,y:3])\;\}
  \end{aligned}\\
&\s{i.\m{next}();} \\
& \begin{aligned}
  \{\;&(\start,[]),\
      &(\t{one},[c:1,x:2]),\
      &(\t{one},[c:1,x:3]),\
      &(\t{two},[c:1,x:2,y:3])\;\}
  \end{aligned}\\
&\s{i.\m{remove}();} \\
& \begin{aligned}
  \{\;&(\start,[]),\
      &(\t{one},[c:1,x:2]),\
      &(\t{one},[c:1,x:3]),\
      &(\t{yBad},[c:1,x:2,y:3])\;\}
  \end{aligned}\\
&\s{j.\m{next}()} \\
& \begin{aligned}
  \{\;&(\start,[]),\
      &(\t{one},[c:1,x:2]),\
      &(\t{one},[c:1,x:3]),\
      &(\error,[c:1,x:2,y:3])\;\}
  \end{aligned}\\
\end{align*}}
\caption{A first example: Running step by step.Lines \{in curly brackets\} describe the state of the automaton;
lines in \texttt{monotype} show the statements that execute;
comments start with //.}
\label{fig:first.steps}
\end{figure} % >>>
\autoref{fig:first.steps} shows an execution of the program and of an automaton for the property \texttt{InvalidateOtherIterators}.
%The lines \{in curly brackets\} describe the state of the automaton;
%the lines in \texttt{monotype} show the statements that execute;
%the other lines are comments.
At a given moment, the automaton has a set of active states.
A state is a pair of a vertex and a store.
The store is a memory that holds (automaton) variables.
Technically, it is a finite partial map from variables to values.
%(A partial finite map is sometimes called a \emph{dictionary}.)
%
%\begin{notation}
We write $[k_1:v_1,k_2:v_2]$ for the finite partial map that maps key~$k_1$ to value~$v_1$, and key~$k_2$ to value~$v_2$.
The empty map is denoted by~$[]$.
%\end{notation}

The automaton has variables $x$,~$y$, and~$c$.
At vertex \texttt{one} the variables $x$~and~$c$ are initialized;
at vertex \texttt{two} the variables $x$,~$y$, and~$c$ are initialized.
At vertex \texttt{one} $x$~is an iterator for a collection~$c$, and
at vertex \texttt{two}, $x$~and~$y$ are both two iterators for the same collection~$c$.
Notice that there is a program variable~\Verb@c@ and an automaton variable~$c$.
The same name was chosen because the two variables always hold the same value in this example.
In general, however, program variables and automaton variables live in different name-spaces, and may hold different values.

%\begin{notation}
To avoid confusion, program variables are typeset in \Verb@monotype@ (\Verb@c@,~\Verb@i@,~\Verb@j@).
Automaton variables are typeset in \textit{italics} ($c$,~$x$,~$y$).
Program variables appear in the program;
automaton variables do \emph{not} appear in the property.
Instead, automaton variable \emph{patterns} appear in the property, and they are typeset in \texttt{\underline{underlined monotype}} (\pattern c,~\pattern C, \pattern x, \pattern X, \pattern y,~\pattern Y).
%\end{notation}
%
The interaction between patterns and automatons' memory is as follows: uppercase patterns write to the automaton memory, and lowercase patterns read from the automaton memory and act as a guard on the transition.

\paragraph{Step~1.}

Initially, only the state $(\start,[])$ is active.
The outgoing transition of vertex \start is labeled by $\pattern X:=\pattern{C}.\mathtt{iterator}()$ and the first executed statement is \verbline[.]{i = c.\PY{n+na}{iterator}()}
A method call matches a label when
\begin{itemize}
\item[(a)] the called method matches the method pattern, and
\item[(b)] the program values match their corresponding patterns.
\end{itemize}
By definition, any value matches an Uppercase pattern.
Here, the values of \Verb@i@~and~\Verb@c@ trivially match the patterns \pattern X~and~\pattern C.
The method itself also matches the method pattern.
For simplicity, we ignore argument types and identify Java methods only by their fully qualified name and their arity.
The called method \texttt{iterator} is in the class \texttt{ArrayList} and has arity~$1$.
We identify it as follows.
\verbline{java.lang.ArrayList.iterator[1]}
Without \texttt{using prefix} directives, the method pattern would be \Verb@iterator[1]@.
With the directives, however, the pattern is the following.
\begin{align*}
&\text{\Verb@java.util.Collection.iterator[1]@} \\
&\text{\Verb@java.util.Iterator.iterator[1]@}
\end{align*}
It means that these two methods \emph{and} all those that override them match.
Here, \texttt{ArrayList} implements \texttt{Collection}.

All conditions are met to enable the transition from \start to \texttt{one}.
When the transition is performed the values that matched \pattern X~and~\pattern C are written in the automaton variables $x$~and~$c$.
For concreteness, let us assume these values are $1$~and~$2$.
After the transition is performed, the state $(\mathtt{one},[c:1,x:2])$ is active.
The state $(\start,[])$ remains active because the implicit transition \verbline{start -> start: *} is also enabled and performed.

\paragraph{Step~2.}
For the second step, the statement to be executed is \verbline[.]{j = c.\PY{n+na}{iterator}()}
Now we need to consider, in turn, the two active states \[\{(\start,[])\quad\text{and}\quad(\texttt{one},[c:1,x:2])\}\]
For $(\start,[])$ the same reasoning as for step 1 holds, so the states $(\start,[])$ and $(\mathtt{one},[c:1,x:3])$ are active after step~2.
Note that now the automaton variable~$x$ remembers the value of the program variable~{\tt j}.
For $(\texttt{one},[c:1,x:2])$ we look at the transitions outgoing from vertex {\tt one}.
\begin{align*}
&\text{\Verb@one -> one: *@} \quad \mbox{ and } \quad 
\text{\Verb@one -> two: \pattern Y := \pattern c.iterator()@}
\end{align*}
The first transitions is always enabled, and performing it keeps states with vertex \texttt{one} active.
The second transitions has two patterns, \pattern Y~and~\pattern c.
The uppercase pattern~\pattern Y always matches, whereas
pattern \pattern c matches only the value held by the automaton variable~$c$.
In this case, $c$ was set in the previous step to the value of the program variable~\texttt{c}.
Therefore, the transition from~\Verb@one@ to~\Verb@two@ is performed and the state $(\mathtt{two},[c:1,x:2,y:3])$ is activated.

\paragraph{Step~3.}

The third step involves the statement
\[\text{\Verb+\PY{n}{i}\PY{o}{.}\PY{n+na}{next}\PY{o}{(}\PY{o}{)}\PY{o}{;}+}\]
which matches no label of outgoing transitions of the currently active vertices (that is, \start, {\tt one}, and {\tt  two}).
Therefore, although the program proceeds, the set of active states of the automaton remains unchanged.

\paragraph{Step~4.}

In the fourth step, the transition $\texttt{two}\to\texttt{yBad}$ is performed.
Notice that the pattern $\pattern{x}.\mathtt{remove}()$ does not have a left-hand side, which simply means that the returned value is irrelevant for this transition.
The states corresponding to vertices \start and {\tt one} remain unchanged, because their outgoing transitions are disabled.
However,  the outgoing transition of state {\tt two} is enabled, and therefore {\tt yBad} becomes active.

\paragraph{Step~5.}

For the fifth and final step, the statement to be executed is \verbline[.]{j.\PY{n+na}{next}()}
The label of the outgoing transition  \[\mathtt{call}\;\pattern{y}.{*}[*]\] of the active state $(\texttt{yBad},[c:1,x:2,y:3]),$
has two distinguishing features: the~$*$ as a method name and the tag \texttt{call}.
As before, in order to match the method name, the prefixes 
\Verb@java.util.Collection.*[*]@ and \Verb@java.util.Iterator.*[*]@
are prepended.  
Then the $*$s are expanded, taking into account the \texttt{CLASSPATH}.
We have a match because the expansion \Verb@java.util.Iterator.next@ is overridden by the method that is actually called.

The tag {\tt call} is used when we want the automaton to take a transition precisely at call-time of a method invocation.
The automaton expresses that a call to one of {\tt j}'s methods while vertex \texttt{yBad} is active constitutes an error.
Notice that this is different from a label like $\pattern X:=\pattern C.\mathtt{iterator}()$ which may match only after the return value is known.

\medskip
The execution we stepped through reaches the \error vertex, so we conclude that the property is violated.
Notice that in order to find a counterexample we need to keep track of the relation between several objects, in particular that iterators {\tt i} and {\tt j} are for the same collection {\tt c}.

% >>>
%\subsection{More on Iterators} \label{sec:examples.iterators} % <<<

%Other interesting properties of iterators~\cite{dblp:conf/oopsla/naeeml08,dblp:conf/sigsoft/boddenlh08,haack2009} are easily  to express in TOPL\null.

%\medskip\emph{Modifying a collection invalidates all its existent iterators:}
%\delimitVerbatim
%\begin{Verbatim}[commandchars=\\\{\}]
%property ModificationInvalidatesIterators
%  using prefix java.util.Collection
%  using prefix java.util.Iterator
%  start -> iterating:    \pattern{I} := \pattern{C}.iterator()
%  iterating -> modified: \pattern{c}.add(*), \pattern{c}.remove(*)
%  modified -> error:     call \pattern{i}.*[*]
%\end{Verbatim}
%\delimitVerbatim
%This property should list all the methods of \textit{Collection} that mutate it.
%If classes that implement \textit{Collection} add mutating methods, then those should be included as well.
%This abstraction leak is intrinsic to Java where sub-classing is not sub-typing.

%\medskip\emph{Iterators should advance only if they are not exhausted:}
%\delimitVerbatim
%\begin{Verbatim}[commandchars=\\\{\}]
%property UnsafeIteratorNext
%  using prefix java.util.Collection
%  using prefix java.util.Iterator
%  start -> iterating:        \pattern{I} := *.iterator()
%  iterating -> notExhausted: \pattern{true} := \pattern{i}.hasNext()
%  notExhausted -> iterating: \pattern{i}.next()
%  iterating -> error:        \pattern{i}.next()
%\end{Verbatim}
%\delimitVerbatim
%The transition from \Verb@iterating@ to \Verb@notExhausted@ is enabled when \Verb@hasNext@ returns \Verb@true@.
%In general, Java literals act as guards on transitions.

%\medskip\emph{Method \Verb@remove@ may only be called after \Verb@next@:}
%\delimitVerbatim
%\begin{Verbatim}[commandchars=\\\{\}]
%property RemoveBeforeNext
%  using prefix java.util.Collection
%  using prefix java.util.Iterator
%  start -> created: \pattern{I} := *.iterator()
%  created -> ok:    \pattern{i}.next()
%  created -> error: \pattern{i}.remove()
%\end{Verbatim}
%\delimitVerbatim
%TOPL is designed to track properties involving multiple objects.
%However, properties involving a single object are also easy to express.
%The vertex \Verb@ok@ is not special.
%The purpose of the transition going to \Verb@ok@ is to deactivate the state with vertex \Verb@created@.

%\medskip
%We have now seen four properties of iterators.
%Each of the previous TOPL properties corresponds to one English sentence.

%\dinocomment{Maybe we need to add also the other example of the paper. Or put the other properties which are not related to iterators}

\subsection{Heap Shape and Values Sensitive Properties}
One interesting kind of properties for object-oriented programs is the ability to reason about the shape of 
the heap composed by the allocated objects. 
The following TOPL's properties test the shape of a linked list and reports an error if it is cyclic or it has the pan-handle shape (i.e., there is a lasso at some point). 
%
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
property ListNotCyclic
   start -> a: \pattern{X} := *.getList()
   a -> a:     \pattern{X} := x.next()
   a -> b:     \pattern{Y} := x.next()
   b -> b:     \pattern{Y} := y.next()
   b -> error: x := y.next()
   a -> error: x := x.next()
\end{Verbatim}
\delimitVerbatim
The idea is that this property will bind the automaton variable $x$
with any possible object in the list, and the $y$ with any possible successors (via the next field) 
of the current binding of $x$. Therefore, if there is a lasso, in the list, this will be detected when a new 
biding of $y$ via a \texttt{b -> b} becomes equal to the binding of $x$. The transition \texttt{a ->error} detect
the case where there is an object pointing to itself. 
%

The following property detects when a dictionary overwrite one of its bindings. 
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
 property BadDictionary
    message "the dictionary overwrite its bindings"
    prefix <Dictionary>
    start -> written:   \pattern{D}.put(\pattern{K}, \pattern{V})
    written -> written: d.put(k, \pattern{V})
    written -> error:   !v := d.get(k)
\end{Verbatim}
\delimitVerbatim
The overwrite is detected by the guard which checks if the value associated with a key $k$ is
the same as the original binding recorded in the automaton variable $v$.



\section{TOPL Syntax and Semantics}
\label{sec:syntax}
The syntax of TOPL is as follows:

%\begin{figure}
\grammar{
  Property& \b{property} Identifier Using\* Transition\* \cr
  Using& \b{using prefix} StringPattern \cr
  Transition& Arc \b: Label \(\b, Label\)\* \cr
  StringPattern& \(Letter \| \b. \| \b*\)\+ \cr
  Arc& Vertex \b{->} Vertex \cr
  Label& Tag\? MethodPattern \cr
  Vertex& Identifier \cr
  Tag& \b{call} \| \b{return} \cr
  MethodPattern& ResultPattern\? NamePattern ArgumentsPattern \cr
  ResultPattern& ValuePattern \b{:=} \cr
  NamePattern& StringPattern \cr
  ArgumentsPattern& \b( \(ValuePattern \(\b, ValuePattern\)\*\)\? \b) \cr
  ArgumentsPattern& \b[ IntegerPattern \b] \cr
  ValuePattern& \b* \| Literal \| UppercaseId \| \b!\? LowercaseId \cr
  IntegerPattern& \b* \| IntegerLiteral \cr
}
%\caption{Syntax of TOPL}
%\label{fig:syntax.topl}
%\end{figure}


A property has a name, a set of \texttt{using} directives, and a set of transitions.
Each transition has an arc (directed edge) and labels.
Each arc has a source and a target vertex.
All vertices are identified by their name.
Labels look like method calls.
Each label has a method pattern that is used to identify the set of methods to which the label refers.
In the simple case, a method pattern consists of a string pattern for the name of the method and an integer that specifies the method arity.
(For simplicity, TOPL does not use the static types of arguments to distinguish between overloaded methods.)
The more interesting case is when there are value patterns for each argument and perhaps even for the result.
Transitions should typically be tagged with \texttt{call} or \texttt{return} to specify exactly at what time they should be performed (see \autoref{sec:semantics.itopl} for details).
%\dinocomment{Does anybody else has the ability to distinguish between call/return?}
%

There are three types of patterns used in TOPL---for strings, integers, and values.
String patterns are POSIX globs~\cite{man:glob.h} and match method names.
(For simplicity, TOPL does not use full regular expressions as string patterns.)
Integer patterns specify method arities.
Value patterns are the most interesting.
For each automaton variable \Verb@v@ there are three associated patterns.
The uppercase pattern \Verb@V@ matches any value and writes it in the automaton variable \Verb@v@.
The lowercase pattern \Verb@v@ reads the value of the automaton variable \Verb@v@ and only matches that value.
The negated lowercase pattern \Verb@!v@ reads the value of the automaton variable \Verb@v@ and only matches different values.
A Java literal acts as a pattern that matches only the value it denotes.
A wildcard~* pattern matches any value.

A TOPL property is \emph{well-formed} when it satisfies the following two conditions:
labels must contain uppercase value patterns at most once, and
any use of a lowercase patterns must be preceded by a use of the corresponding uppercase pattern on all paths from the \start vertex (i.e., automaton variables must be written before being read).
%
From now on we assume TOPL properties to be well-formed.



\subsection{Semantics}\label{sec:semantics} % <<<
We model the semantics of programs and automata as sets of event traces.
We say that a program \emph{violates} a property when their sets of traces intersect.
In other words, properties encode bad executions, rather than good executions.

\subsubsection{TOPL execution automata.}
\newcommand{\World}{ExecState}

Each TOPL's property when considered in conjunction with the set of traces defining the semantics of the program,
gives rise to an automaton defined over the labeled multigraph  on $\set{Vertex}$ and $\set{Arc}$ representing the 
semantics of the property interpreted over the program.
$\set{Vertex}$ is the set of vertices mentioned as endpoints of the arcs and $\set{Arc}$ is the set of labeled arcs mentioned in transitions. The automaton has two special vertices, {\tt start} and {\tt error},  i.e., the initial and accepting vertex respectively. 

We assume a countable set \set{Value} of values and a countable set $\set{Variable}$ of automaton variables. Let stores be finite partial maps with finite domain.
\[
\set{Store} = \set{Variable} \pmap_{\mathit{fin}} \set{Value}
\]
Moreover we assume a countable set \set{Event} of events with known arity. Each event~$e$ is of the form $(t_e,[0: v_0,\dots, 1:v_n])$.
The component $t_e$ is a tag, e.g., call or return, while the second component is an array of values.
Within guards and actions we write $tag(e)$ for the tag, and $e[i]$ for the $i$th value of the array.
%
\begin{definition}[TOPL execution automaton]
Given a TOPL property $(\set{Vertex},\set{Arc})$ and a set of program traces $\set{Trace}$, a {\em TOPL execution automaton} $\Xi$ is a tuple 
$(\set{State}, \to , \set{Init}, \set{Error})$ where
\begin{itemize}
\item $\set{\World} \subseteq (\set{Vertex}\times \set{Store})\times\set{Trace}$ is a set of {\em execution states}.
\item $\to \subseteq \set{\World} \times \set{\World}$ is a set of {\em execution transitions}
\item $\set{Init}= \{ (\texttt{start}, [], \tau) \mid \tau \in \set{Trace} \}$ is the set of initial execution states;
\item $\set{Error} \subseteq \{ (\texttt{error}, \sigma), \tau) \mid \sigma \in \set{Store},  \ \tau \in \set{Trace} \}$ is the set of accepting (error) execution states.
\end{itemize} 
\end{definition}
A state of the automaton is
given by specifying the vertex in the graph as well as the value of defined automaton variables and a trace of events to be
observed. The reader may wonder why execution states need to contain traces. The reason is that
each label in $\set{Arc}$ carries (potentially) a list of guards and 
we call the length of this list, the \emph{depth} of the arc.
Since different outgoing arcs for a vertex can have different depths, we have that 
different target states of execution transitions may receive different events.
For example for a trace of events $e_1 e_2 e_3\cdots$, if two outgoing transitions from the same state have
depth 2 and 5 rispectively,
then the end state of the first transition will see $e_3$, while the end state of the second transition $e_6$. 

In order to define the transition relation $\to$ we need to define two auxiliary concepts. 
The effect of the actions in an arc label on a store when observing a trace is given by the function
\[
   A : \set{Store} \times \set{Trace} \times \set{Label} \to \set{Store}_\bot
\] and defined as
%
\[
\begin{array}{c}
\begin{array}{lclclcl}
A(\sigma,\epsilon,[]) & = & \bot
& \qquad &
A(\sigma,e,(g,a)) & = & \left\{\begin{array}{ll}
     a(e,\sigma) & \mbox{if $g(e,\sigma)$}
     \\[1ex]
     \bot & \mbox{otherwise}
     \end{array}
     \right.
\end{array}
\\[4ex]
\begin{array}{lcl}
A(\sigma,e\cdot \tau,(g,a)\cdot l) & = & \left\{\begin{array}{ll}
     A(\sigma',\tau,l) & \mbox{if $|\tau|=|l|>0$} 
     \\
& \mbox{and  $A(\sigma,e,(g,a))=\sigma'$}
     \\[1ex]
     \bot & \mbox{otherwise}
     \end{array}
     \right.
\end{array}
\end{array}\]
In this definition, if the event $e$ passes the guard $g$ in the store $\sigma$, the corresponding action $a$ is performed on that event
and therefore updating the store $\sigma$.
With $A$ we can define the predicates $enabled$
testing whether a transition is enabled in a store when observing a trace,  and a predicate
$Enabled$ testing if there exists an enabled transition starting from an execution state:
\begin{eqnarray*}
enabled(\sigma,\tau,l) & \Leftrightarrow & A(\sigma,\tau,l) \neq \bot
\\
Enabled(x,\sigma,\tau) & \Leftrightarrow  & \bigvee \{ enabled(\sigma,\tau,l) \mid x \to x' : l \}
\end{eqnarray*}
Notice that, according to the definition of $enabled(\sigma,\tau,l)$, and in turn of the function $A$, 
for a transition to be enabled, all the guards along its
list have to evaluate to true. Evaluating a guard along the transition consumes
an event |  therefore | to see if a transition is enabled 
we have to examine $|l|$ events. 

%
The transition relation $s \to s'$ is defined by the following rules.
\[
\begin{array}{ll}
\text{(Step)}  &
\infer[x_1 \to x_2{:} l \mbox{ and } |l|=|\tau_1| ]{ (x_1,\sigma_1,\tau_1 \cdot \tau_2 ) \  \to \  (x_2, \sigma_2, \tau_2)}{A(\sigma_1,\tau_1,l)=\sigma_2}
\\[2ex]
\text{(Silent)}  & 
\infer[\neg Enabled(x_1,\sigma_1,\tau_1) ]{ (x_1,\sigma_1,\tau_1) \  \to \  (x_1, \sigma_1, \tau_2)}{ \tau_1=e \cdot \tau_2}
\end{array}
\]
Finally, we can define the language of a TOPL execution automaton $\Xi$, as the set of traces it accepts:
\[
{\cal L}(\Xi) = \{ \tau \mid \exists \sigma' \tau', (\mathtt{start},[],\tau) \to^* (\mathtt{error},\sigma',\tau')\}
\]
${\cal L}(\Xi)$ are the traces that drive the automaton $\Xi$ from the \texttt{start} vertex (with an empty store) to the \texttt{error} vertex.

\paragraph{Silent steps.}
A peculiar aspect of the transition relation $\to$ is that if no transitions are enabled for a given
state and trace of events, the automaton does not get stuck but it
consumes one event without changing its state (see the  Silent Step rule). Note that
a silent step is not equivalent to a self-loop on all states, as
dropping events is not allowed if there are enabled
transitions. In that case,  the enabled transitions are performed 
with the rule (Step) and
the automaton execution state becomes $(x_2, \sigma_2,\tau_2)$, where $x_2$ is the target vertex of
the arc of the transition, $\sigma_2$ is defined by the modification imposed by the function $A$ and
$\tau_2$ is the leftover of the event trace before the transition after dropping
$|l|$ events.
\begin{example}
Consider the two automata in Figure~\ref{fig:unmatched-example} and assume that the set of active states for the left-hand side automaton is $\{ \texttt{zero} \}$ and for the right-hand side one is $\{ \texttt{three}\}$. Moreover, let us assume that our input trace is 
\[
\cdots e_1 e_1 e_2 \cdots
\] In the left-hand side automaton, the first occurrence of the event $e_1$ enables the transition  from {\tt zero} to {\tt two}, however, the transition from {\tt zero} to {\tt one} cannot fire since the first occurrence of $e_1$ is followed by another $e_1$.
Consequently, after the first occurrence of $e_1$ state {\tt two} becomes active and {\tt zero} inactive. 
Notice that, in the left-hand side automaton, state {\tt one} cannot be reached by 
the trace $e_1 e_1 e_2 $ from {\tt zero}. 
On the contrary, for the right-hand side automaton, the first occurrence of $e_1$ does not enable any transition per se. 
Notice that the only outgoing transition on the active state {\tt three} needs a sequence of two events to be enabled. Hence, we need to consider the sequence $e_1e_1$. The latter does not enable any transition either. Therefore, according to our semantics,  the first occurrence of $e_1$ is consumed silently and the set of active states (i.e., $\{ \texttt{three} \}$) remains unchanged. At this point, the second occurrence of $e_1$ is considered, and since it is followed by $e_2$ the transition from {\tt three} to {\tt four} becomes is enabled, the events $e_1e_2$ are consumed and {\tt four} becomes active whereas {\tt three} inactive.
\end{example}
%\begin{example}
%Consider {\em Step 3} in Section~\ref{}. The event produced by the statement 
%\[\text{\Verb+\PY{n}{i}\PY{o}{.}\PY{n+na}{next}\PY{o}{(}\PY{o}{)}\PY{o}{;}+}\] 
%is not matched by any transitions starting from states {\tt one} or {\tt two} in the automaton of Fig~\ref{}. 
%This event is silently consumed but the set of active states does not change. 
%The automaton will take a transition as soon as a suitable event matching an outgoing transition of an active state is encountered in the trace.
%\end{example}
%
%
\begin{figure}
\begin{tikzpicture}
  \def\x{2.5}
  \tikzset{vertex/.style={draw,circle,inner sep=1pt}}
  \tikzset{transition/.style={->,>=latex}}
  \tikzset{every label/.style={gray}}
  \node[vertex] (zero) at (0,0) [label=above:\texttt{zero}] {};
  \node[vertex] (one) at (-1,-1) [label=left:\texttt{one}] {};
  \node[vertex] (two) at (1,-1) [label=right:\texttt{two}] {};

  \node[vertex] (three) at (3,0) [label=left:\texttt{three}] {};
  \node[vertex] (four) at (4,0) [label=right:\texttt{four}] {};
  
  \draw[transition] (zero)--node[left]{$ e_1;e_2$} (one);
  \draw[transition] (zero)--node[right]{$e_1$} (two);
  
  \draw[transition] (three)--node[above]{$e_1;e_2$} (four);
\end{tikzpicture}
\caption{Example of unmatched events.}
\label{fig:unmatched-example}
\end{figure}



\subsubsection{On labels and guards.}
 A label is a list of pairs $(g,a)$ of guards and actions. A  {\em general guard} is a partial function of type:
\[
\set{GenGuard} = (\set{Pattern} \times \N \times \set{Pred}) \pmap (\set{Event}\times\set{Store}) \to \B
\]
A general guard can be instantiated with a pattern  name, $\pattern v$,  its position $i$ in the label, and a predicate $p$ needed to test this pattern. By providing these arguments we obtained an {\em instantiated guard}:
\[
g_{\pattern{v},i,p} : \set{Event}\times\set{Store} \to \B
\]
that given an event and a store evaluate whether the event satisfy the guard in the store. It is defined as:
\newcommand{\sem}[1]{[ \! | #1 | \! ]}
\[
g_{\pattern{v},i,p}(e, \sigma) = p(e[i],\sigma(\pattern v))
\] The guard is true if and only if the value of $\pattern{v}$ in the automaton store 
and the value of $i$-th parameter of  event $e$ (obtained from the program store) satisfy $p$.
\begin{example}
Consider the label 
 $\sim \pattern {v} := \pattern {s}.gets(\pattern {k})$ to be matched with the statement 
 {\tt t:=z.gets(h)}. Internally,  the label is compiled down to the sequences 
\[
\pattern{call} \  \pattern{s}^0 .gets(\pattern {k}^1);  \ \pattern{ret} \ gets = \sim \pattern {v}^0   
\] The upper-script stands for the position of a pattern or an expression. The statement generates the trace of events $e_1 \cdot e_2$ where 
\[ 
 e_1=(call \ gets, [0: \sem{z}, \ 1: \sem{h}])  \quad \mbox{ and }  \quad e_2= (ret \ gets, [0: \sem{t}])
\] 
The instantiated guard for the label are:
 $g_{\pattern{s},0,=}$, $g_{\pattern{k},1,=}$, and  $g_{\pattern{v},0, \neq}$.  
Notice that the predicates we want to compare patterns and events' values are: equality for the element $\pattern{s}$ and $\pattern{k}$, 
but inequality for \pattern{v} (because of $\sim$).
The instantiated guards, can now be evaluated with the events by taking their conjunction:
\[ 
 (tag(e_1)= \ call \ gets) \wedge g_{\pattern{s},0,=}(\sigma,e_1) \wedge g_{\pattern{k},1,=}(\sigma, e_1) 
\] and 
\[ 
 (tag(e_2)= ret \ gets) \wedge g_{\pattern{v},0,\neq}(\sigma,e_2).
\]
\end{example}



\section{Run-time checking}
\label{sec:dynamic}
In this section we describe an algorithm to check at run-time  TOPL properties on Java programs.
%
Figure~\ref{architecture} summarises our method. There are two main components: 
the {\em TOPL compiler} and the {\em Property Checker}.
The TOPL compiler takes as input the compiled class files and the list of TOPL properties to be checked against the classes. The compiler has two submodules: the {\em instrumenter} and the {\em automaton generator}.
The latter synthesises a Java program that precisely encodes the set of automata representing the TOPL properties. The instrumenter instruments the byte code with calls to methods of the Java encoding of the automata.
During their tasks, the two submodules need to exchange information about method identifiers, therefore their operations are intertwined.   
The property checker module can be seen as a general interpreter able to execute TOPL automata properties. When compiled together with the Java encoding of the automata generated by the TOPL compiler, we obtain an executable property checker instantiated to the particular list of TOPL properties we want to check against the initial class files.
When run together with the instrumented class files, the instantiated property checker acts as a monitor that is able to detect violation of the properties of interest.

%In the following we give a detailed description of the TOPL compiler and the Property checker.
\dinocomment{to myself: what's the difference with Polymer?}
%
\begin{figure}[htbp]
\begin{center}
%\includegraphics[scale=.35]{TOPL.pdf}
\input{architecture}
\caption{Architecture of TOPL properties' run-time checking.}
\label{architecture}
\end{center}
\end{figure}

\subsection{Run-time completeness}
\dinocomment{Rewrite in term of "security".}
A legitimate question about our run-time checker is whether it is {\em complete}. Informally, that can be expressed as:
\begin{quote}
if any run-time execution of the program leads to an error then will the checker detect the error?
\end{quote}
The program in Figure~\ref{fig:completeness} shows that in order to
achieve completeness any run-time checker would need an unbounded
amount of memory. The method {\tt NeedsUnboundedMemory(int n)}
declares an array of iterators of a length depending on the external parameter {\tt n}.  In the {\tt for} loop, the array is filled with iterators on the same collection {\tt c} and randomly some of them are exhausted by advancing them till the end (inner {\tt while} loop).
Outside the {\tt for} loop, a random iterator is advanced one more time and we would get an exception if this iterator 
was one of those exhausted in the previous loop. Because of the random choice of iterators, it becomes apparent that, 
if we were to decide at {\tt a[r.nextInt(n)].next()} whether an exception needs to be thrown or not, we would need to keep information about all the iterators. Moreover, since their number {\tt n} is a parameter, there is no way to bound the amount of memory this checker would need for keeping track of all the iterators. 
%Therefore we conclude that any run-time checker would need {\em unbounded memory} to detect whether this program %gives an exception or not. 
%
\begin{figure}[htbp]
\begin{center}
\include{Completeness}
\caption{Counterexample to run-time completeness.}
\label{fig:completeness}
\end{center}
\end{figure}

\dinocomment{discuss about: conservative and transparent properties of an inliner}
\dinocomment{talk about our strategy}
\subsection{Checker}
\subsection{Byte code instrumentation}

\section{Experimental Results}

\dinocomment{experiments: TOMCAT, ANT, Eclipse and Dacapo benchmarks}

% >>>
\section{Related Work}\label{sec:related} %<<<
Our work is based on the concept of typestate~\cite{strom1986} originally developed for imperative programs and extends this fundamental concept by integrating notions typical of object-oriented programs. 
We are certainly not the first in doing this: there are several extensions of typestate to object-oriented programming in the literature.
A modular static verification method for typestate protocols is introduces in~\cite{dblp:conf/oopsla/bierhoffa07}. 
The specification method is based on linear logic and relations among objects in the protocol are monitored by a tailored system of permissions. 
The method is highly modular and presumably efficient. The specification of the interactions among objects by means of permissions adds an extra level of machinery which increases the gap between the intuitive protocol description and its formalization. Similarly~\cite{deline2004,dblp:conf/sigsoft/BierhoffA05} provide a mean to specify typestate properties that belong to a single object. The specified properties are reminiscent of contracts or pre/post-conditions for methods and
can deal with inheritance.
In~\cite{dblp:conf/issta/FinkYDRG06} the authors present sound verification techniques for typestate properties of Java  programs.
Their approach is divided in several stages with different verifiers varying for cost and precision.
In the early stages efficient but imprecise analyses are employed whereas
more expensive and precise techniques are then progressively employed in later stages.
Every stage focuses on verifying only the parts of the code that previous stages failed to verify.
It is likely that our TOPL language could be fruitfully combined with their analysis technique.

An automaton-based formalism for specifying properties of software interfaces were introduced in~\cite{dblp:conf/sigsoft/AlfaroH01} . 
This language aims at capturing assumptions about the order in which the methods of a component are called and the order in which the component calls external method.
In contrast to \TPL, this formalism is mainly used to check the compatibility of the interfaces of two components and it is designed to be applied at  model level rather than code level. A specification language for interface checking aimed to C programs (called SLIC) is introduced in~\cite{ball2002}.  
Differences between SLIC and \TPL \ include: the use (in SLIC) of
non-determinism to encode universal quantification of dynamically allocated data, and the  ability to have complex code in the automaton transitions. 
\TPL \ specifications naturally express universally quantified
properties over data structures and for computability reasons,  we
have chosen to limit the  actions performed during automaton transitions. 
Simple SLIC specifications are verified by  the SLAM verifier~\cite{dblp:conf/cav/ballr01}.
While SLAM specialises on device drivers and checks client conformance rather than full protocols, 
very general specifications of object-oriented program behaviour can be given in JML~\cite{jml} and Spec$\sharp$~\cite{DBLP:journals/jot/BarnettDFLS04}. However the latter two languages focus on class specifications and do not have temporal features.

In~\cite{disney2011} contracts are used to express legal traces of
programs in a functional language with references. The contracts
specify traces as regular expressions over calls and returns and so
look similar to our automatons, if for a quite different
setting. Here, the specifications are function-centered, though, and
again, capturing inter object relations seems somewhat awkward.

\dinocomment{Add more on dynamic checks and byte code instrumentation}

% >>>
\section{Conclusions and Future Work}\label{sec:conclusions} %<<<

\paragraph{}
We introduced TOPL---a language for expressing temporal safety properties for object-oriented programs.
TOPL properties can express constraints involving the relation of many objects at the same time. 
Furthermore, we introduced a technique for checking at run-time the violation of the properties
on Java program. We have applied our technique to a variety of programs including large open source Java projects.
%
\paragraph{Future work.}
In the future, we intend to make use of separation logic~\cite{reynolds2002} to deal with the heavy use of the heap and aliasing in object-oriented software. Moreover, we aim at developing static analysis techniques for \TPL \ properties of Java programs using the jStar framework~\cite{DBLP:conf/oopsla/DistefanoP08}.
This will require investigating suitable abstraction techniques for obtaining meaningful and precise over-approximations of the state space of the programs.
Finally, we intend to develop a tailored bi-abduction inference technology~\cite{dblp:conf/popl/CalcagnoDOY09} which would help with scalability of the analysis.
\dinocomment{Mention that we want to at least reach runtime soundness with abstractions}


%>>>

%\softraggedright
\bibliographystyle{plain}
\bibliography{safety}
\end{document}
% vim:spell errorformat=%f\:%l-%m,%f\:%l\:%m,%f\:%m
% vim:fmr=<<<,>>>:
