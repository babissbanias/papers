\def\para#1{\medskip\penalty-250\noindent{\bf#1}\quad}
\def\A{\para{A:}}
\def\Q{\para{Q:}}

\Q Can we use FreeBoogie instead of Boogie already?

\A No. There are unfortunatelly many wrinkles that need to be straightened.
A particularly annoying one is that the implementation of loop cutting has
a soundness bug. A complete list of known issues appears on FreeBoogie's
site at Google Code. So far, the development of FreeBoogie happened in
coding sprints. There was one in 2007, one in 2008, and one in 2009, each
about six weeks in length. The one for 2010 is overdue. It {\it must\/}
happen before Christmas, preferably earlier.

\Q What is the main contribution of your PhD?

\Q What is the main {\it theoretical\/} contribution of your PhD?

\Q Does FreeBoogie handle loops?

\A [Note: Don't forget to compare with symbolic execution and abstract
interpretation.] [Note: Explain how cutting {\it should\/} be done.]

\Q Did you describe FreeBoogie's design in a peer-reviewed paper?

\Q Should verification condition generators use weakest precondition or
strongest postcondition?

\A [Note: Mention the triggers gotcha.]

\Q The comparion between different types of semantics is pretty standard,
isn't it?

\Q You present a proof technique for showing the correctness of algorithms
that simplify verification conditions. What exactly are the properties an
algorithm needs in order to be able to apply this proof technique?

\Q Does FreeBoogie handle Boogie's polymorphic types?

\Q Isn't it cheating to assume that loops have been dealt with when you
address code reachability?

\Q Your reachability analysis identifies four very different types of
problems.  Are these problems distinguished in error messages? If no, then
how can it be done?

\Q The example you give in the introduction is quite algorithmic in nature.
Why do you think this is the kind of problems that ``program verifiers
ought to be able'' to handle ``in the future''?

\Q You suggest that the front-end of program verifiers is uninteresting.
Why?

\Q You say that `insights' lead to simpler and more efficient
implementations.  Which insight leads to which efficiency gain? Which
insight leads to which simplification?

\Q What does `structural' mean in `structural operational semantics'?
(Does it describe `operational semantics' or does it restrict to a kind?)

\Q Why do you say that denotational semantics are not much used today?

\Q What is a Kripke structure?

\Q Which SMT solver did you use?

\Q How does Boogie compare to Why?

\Q How does ACSL compare to JML?

\Q There is a standard command language for SMT provers. Why do you say
this is prover dependent?

\Q Who uses FreeBoogie? What are the future plans for it?

\Q How big is the codebase of FreeBoogie?

\Q What {\it are\/} the differences between symbolic execution and abstract
interpretation?

\Q How come Kleene's algorithm for building regular expressions out of
automata and Gauss's algorithm for solving systems of linear equations are
$kij$ algorithms?

\Q You say that ``fortunately, the dissertation does not stem from one big
contribution, but rather from many smaller ones that are related.'' I would
say this is {\it unfortunate}, because any set of articles with unimportant
contributions from some area of research can be described in the same way.
So, how is your thesis different from a set of unimportant articles glued
together, which are `related' only because they fit roughly the same
research area?

\Q What are the important design decisions and how did they affect
FreeBoogie?

\Q On what kind of formulas does {\it prune\/} work well?

\Q Why develop FreeBoogie when the Boogie tool from MSR is open source?

\Q Is parallel assignment in core Boogie? The grammar in Figure~2.2 says
``no,'' the typing rule in Figure~2.5 says ``yes.''

\A Parallel assignment is not handles by the semantics explicitly. The
typing rule is too optimistic.

\Q You say that ``Boogie does not facilitate reasoning about termination.''
What kind of features would make it easy to reason about termination?

\Q You say that FreeBoogie adds prover-dependent axioms. Does it use
multiple provers? Can you give an example of an axiom that is sent in one
way to one prover and another way to another prover?

\Q Does FreeBoogie handle triggers? Aren't the benchmarks for wp/sp
meaningless in the absence of triggers?

\Q The `unsharing' algorithm seems to be a very heavyweight solution to a
problem that has a simple engineering solution: communicate with the prover
using its API. How do you comment?

\Q Chapter~3 is very different from the others and makes the dissertation
heterogenous. Is there any reason it should stay?

\Q Aren't there too many jokes?

\Q Is AstGen a contribution of you thesis? It seems that you simply
describe in too much detail some engineering effort.

\A [Note: Mention research on similar tools. Yes, it is a contribution, but
not central.]

\Q Why did you waste time developing AstGen instead of using some existing
infrastructure for developing compilers?

\Q You describe a very general type of visitors, which makes the
description hard to follow. Moreover, you only use `normal' visitors, so
the general description is not needed. Why did you do it?

\Q Is there anything novel about the way you use visitors?

\Q What is the difference between an interpretation of a formula and a
model of a formula?

\Q How does FreeBoogie's prover interface compare to that of Why?

\Q You say that Benton's technique of doing equivalence proofs fits well
with the Boogie language. Can you elaborate?

\Q Why does FreeBoogie not support the SMT language?

\A [When the backend was developed, there was no SMT command language.]

\Q How many users does FreeBoogie have? If none, then why?

\Q Why isn't reachability analysis implemented in FreeBoogie?

\Q There is one chapter about incremental verification and one chapter
about semantic reachability analysis. None is implemented in FreeBoogie. It
seems that the theoretical work is not sufficiently backed by experimental
evidence.  How do you comment?

\Q Can you characterize the programs for which the weakest precondition is
superpolynomial? What about the strongest postcondition?

\Q Can you shorten the background on computational complexity?

\A [I'd rather have {\it more\/} background in the other chapters.]

\Q Why is a passive form of~$G$ equivalent to~$G$? (Page~52 states that ``it
is easy to see''.)

\Q You say that $16\%$~of Boogie benchmarks use {\bf goto} in an
interesting way. Can you give an example?

\Q Why do you introduce the notion of {\it non-redundant\/} passive
form?

\A [See Theorem 2 and Conjecture 1.]



\bye
% vim:textwidth=75:
