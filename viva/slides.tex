%{{{ prelude
\documentclass{beamer}
\usepackage[T1]{fontenc}
\usepackage[math]{iwona}
\usepackage{hyperref}
\usepackage{pgfpages}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{xspace}

\setbeamertemplate{navigation symbols}{}
\setbeamercolor{normal text}{bg=black,fg=white}
\setbeamercolor{alerted text}{fg=yellow}
\setbeamercolor{structure}{fg=green}

\newcommand{\titletext}{The Design and Algorithms of a Verification Condition
  Generator}
\definecolor{lightblue}{rgb}{0.5,0.5,1}
\hypersetup{colorlinks,linkcolor=lightblue,citecolor=lightblue,urlcolor=lightblue}
\hypersetup{
  pdfauthor={Radu Grigore},
  pdftitle={\titletext}}

\tikzset{statement/.style={
  rectangle,
  draw,thick,
  inner sep=2pt,minimum height=3ex}}
\tikzset{>=latex}
\tikzset{shorten >=1pt}

\title{\titletext}
\author{Radu Grigore}
\date{23 August 2010}

\newcommand{\specsharp}{Spec$^\sharp$\xspace}
\def\,#1{{\lineskiplimit=0pt \oalign{\relax#1\crcr\hidewidth,\hidewidth}}}

\begin{document}
\maketitle
%{{{ plan
% Audience: Rustan and Henry.
% Principles:
%   - give a good overview
%     - spend plenty of time explaining how pieces fit together
%     - mention all the contributions explicitly
%   - go in depth into one subject (say, reachability)
% Plan
%   - here's the field and why it's interesting
%   - here's what I did and why it's important
%   - here's some clever details
%   - 
% Extra slides (for answering questions):
%   - TODO 
%}}}
%{{{ motivation
\begin{frame}
  \begin{block}{formal methods}
  \begin{itemize}
  \item use mathematics to improve the quality of software
  \item appealing because
    \begin{itemize}
    \item potentially very useful
    \item many small beautiful problems
    \end{itemize}
  \item directions
    \begin{itemize}
    \item how should humans think about programs
    \item how should machines think about programs
    \end{itemize}
  \end{itemize}
  \end{block}

  \begin{block}{program verifiers}
  \begin{itemize}
  \item high quality new code
  \item fix problems in old code
  \end{itemize}
  \end{block}
\end{frame}
%}}}
%{{{ FreeBoogie
\begin{frame}
  \begin{block}{\specsharp architecture}
  \begin{itemize}
  \item \specsharp compiler (frontend)
  \item Boogie tool (backend)
    \begin{itemize}
    \item \emph{verification condition generator}
    \item SMT solver
    \end{itemize}
  \end{itemize}
  \end{block}
  \begin{block}{improvements}
  \begin{itemize}
  \item \alert{configurable method}
    \begin{itemize}
    \item weakest precondition
    \item strongest postcondition
    \end{itemize}
  \item analyzes
    \begin{itemize}
    \item partial correctness
    \item \alert{reachability}
    \end{itemize}
  \item \alert{incremental}
  \end{itemize}
  \end{block}
\end{frame}
%}}}
%{{{ Boogie example
\newcommand{\sequentialsearch}[1]{
  \begin{tikzpicture}[x={(2.25cm,0cm)},y={(0cm,-1cm)}]
    \def\prop##1{\ifnum#1=##1yellow\fi}
    \foreach \n/\p/\l in {
        0/{(0,0)}/{$i:=0$},
        1/{(-1,1)}/{\textbf{assume} $i<n\land v[i]\ne u$},
        2/{(-1,2)}/{$i:=i+1$},
        3/{(1,1)}/{\textbf{assume} $i\ge n\lor v[i]=u)$},
        4/{(1,2)}/{\textbf{assert} $v[i]=u$},
        5/{(1,3)}/{\textbf{return}}}
      \node[statement,\prop\n] (\n) at \p {\l};
    \draw[->] (2) .. controls (-2.3,4.5) and (-2.3,-1.5) ..  (1);
    \foreach \m/\n in {0/1,0/3,1/2,2/3,3/4,4/5}
      \draw[->] (\m)--(\n);
  \end{tikzpicture}}

\begin{frame}
\begin{align*}
\\
\end{align*}
\begin{center}
  \sequentialsearch9
\end{center}
\end{frame}

\begin{frame}
\begin{align*}
\\
  \alert{\sigma_0=[i\mapsto7,v\mapsto[9,8,6],n\mapsto3,u\mapsto8]}
\end{align*}
\begin{center}
  \sequentialsearch0
\end{center}
\end{frame}

\begin{frame}
\begin{align*}
  \sigma_0=[i\mapsto7,v\mapsto[9,8,6],n\mapsto3,u\mapsto8]
\\
  \alert{\sigma_1=[i\mapsto0,v\mapsto[9,8,6],n\mapsto3,u\mapsto8]}
\end{align*}
\begin{center}
  \sequentialsearch1
\end{center}
\end{frame}

\begin{frame}
\begin{align*}
  \sigma_0=[i\mapsto7,v\mapsto[9,8,6],n\mapsto3,u\mapsto8]
\\
  \alert{\sigma_1=[i\mapsto0,v\mapsto[9,8,6],n\mapsto3,u\mapsto8]}
\end{align*}
\begin{center}
  \sequentialsearch2
\end{center}
\end{frame}

\begin{frame}
\begin{align*}
  \sigma_1=[i\mapsto0,v\mapsto[9,8,6],n\mapsto3,u\mapsto8]
\\
  \alert{\sigma_2=[i\mapsto1,v\mapsto[9,8,6],n\mapsto3,u\mapsto8]}
\end{align*}
\begin{center}
  \sequentialsearch3
\end{center}
\end{frame}

\begin{frame}
\begin{align*}
  \sigma_1=[i\mapsto0,v\mapsto[9,8,6],n\mapsto3,u\mapsto8]
\\
  \alert{\sigma_2=[i\mapsto1,v\mapsto[9,8,6],n\mapsto3,u\mapsto8]}
\end{align*}
\begin{center}
  \sequentialsearch4
\end{center}
\end{frame}

\begin{frame}
\begin{align*}
  \sigma_1=[i\mapsto0,v\mapsto[9,8,6],n\mapsto3,u\mapsto8]
\\
  \alert{\sigma_2=[i\mapsto1,v\mapsto[9,8,6],n\mapsto3,u\mapsto8]}
\end{align*}
\begin{center}
  \sequentialsearch5
\end{center}
\end{frame}


\begin{frame}
  \frametitle{Contributions}
  \begin{itemize}
  \item semantics for core Boogie: operational, Hoare, wp, sp, relation
  \item novel use of Visitors, and the supporting tool AstGen; there's
    also a discussion of the overall design
  \item precise definition of passivation (also by Vogels, Jacobs, Pissens)
  \item study of the complexity of the passivation problem
  \item experimental comparison of wp vs sp
  \item algorithm for unsharing expression dags
  \item proof technique for algorithms that simplify verification conditions
  \item heuristic for detecting common parts of expression trees
  \item why is reachability analysis useful (in addition to correctness
    and termination)
  \item heuristics that make reachability analysis practical 
  \end{itemize}
\end{frame}
%}}}
%{{{ old
\begin{frame}
  \frametitle{Reachability Analysis for Annotated Code}
  coauthors: Mikol\'a\v{s} Janota and Micha{\l} Moskal\bigskip
  \begin{itemize}
  \item We present a general technique to catch
    \begin{itemize}
    \item \emph{dead code},
    \item bugs (or intended unsoundness) in the VC generator,
    \item inconsistent axiomatizations or specifications, and
    \item assertions that always fail (doomed code).
    \end{itemize}
  \item The technique is simple because
    \begin{itemize}
    \item we rely on a previous stage to cut loops and
    \item we use strongest postcondition (instead of wp).
    \end{itemize}
  \item The naive implementation is unusably slow, as it calls
    the prover once per program point. I sped that up to $<2$
    calls to the prover per method on average, which made it 
    usable.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Edit and Verify}
  coauthor: Micha{\l} Moskal\bigskip
  \begin{itemize}
  \item Idea: If the program and specs changed a little since
    the last verification, then don't redo all the work!
  \item proof of concept implementation in Fx7
    \begin{itemize}
    \item keep the last prover query
    \item preprocess the new query, using the previous one
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Strongest Postcondition of Unstructured Programs}
  coauthors: Julien Charles, Fintan Fairmichael, Joseph Kiniry
  \bigskip
  \begin{enumerate}
  \item semantics
    \begin{itemize}
    \item correctness of a flowgraph
    \item Hoare triples vs WP vs SP
    \end{itemize}
  \item algorithms
    \begin{itemize}
    \item \emph{definition of passive form}
    \item complexity of finding an optimal passive form
    \end{itemize}
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{FreeBoogie}
  \begin{itemize}
  \item Java clone of MSR's Boogie
  \item platform for some research
  \item status
    \begin{itemize}
    \item after a major change that is not quite finished:
      BoogiePL$\to$Boogie2
    \item main missing parts:
      \begin{itemize}
      \item invariants inference
      \item encoding Boogie2 types
      \end{itemize}
    \end{itemize}
  \item 
  \end{itemize}
\end{frame}
%}}}
%{{{ Q&A
\begin{frame}
\centerline{\Huge Q\&A}
\end{frame}
%}}}
\end{document}

